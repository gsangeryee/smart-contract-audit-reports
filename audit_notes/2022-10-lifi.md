# 2022-10-LiFi
---
- Category: #Dexes #Bridge #services #cross-chain #liquidity_manager 
- Note Create 2025-03-27
- Platform: Spearbit
- Report Url: [LiFi Spearbit Security Review](https://github.com/spearbit/portfolio/blob/master/pdfs/LIFI-Spearbit-Security-Review.pdf)
---
# Critical & High Risk Findings (xx)

---
## [H-07] LiFi protocol isn't hardened
----
- **Tags**:  #business_logic 
- Number of finders: 3
- Difficulty: Medium
---
### Description: 

The usage of the LiFi protocol depends largely on off chain APIs. It takes all values, fees, limits, chain ids and addresses to be called from the APIs and doesn’t verify them. Several elements are not connected via smart contracts but via the API, for example: 
- the `emits` of `LiFiTransferStarted` versus the bridge transactions. 
- the fees paid to the `FeeCollector` versus the bridge transactions.
- the Periphery contracts as defined in the `PeripheryRegistryFacet` versus the rest. 

In case the API and or frontend contain errors or are hacked then tokens could be easily lost. Also, when calling the LiFi contracts directly or via other smart contracts, it is rather trivial to commit mistakes and loose tokens. 

Emit data can be easily disturbed by malicious actors, making it unusable. The payment of fees can be easily circumvented by accessing the contracts directly. It is easy to make fake websites which trick users into signing transactions which seem to be for LiFi but result in loosing tokens. 

With the current design, the power of smart contracts isn’t used and it introduces numerous risks as described in the rest of this report. 

### Recommendation: 

Determine if you want the LiFi protocol also to be used at a smart contract level (e.g. to be integrated in other smart contracts). 
- If so: then harden the functions and connect them.
- If not: then add access controls and/or verification checks in all the bridge functions to verify that transactions and values only originate from the LiFi APIs. This can be done by signing data or white-listing the calling addresses.
### Discussion

LiFi: After discussing this internally, we have decided that for now we plan to keep the protocol as is and rely on the API to generate correct behavior. We don’t plan to lock the protocol down in such a way to prevent developers from using the contracts freely. We acknowledge the risks inherent in that and plan to mitigate as much as possible without a full lockdown. 
Spearbit: Acknowledged.
### Notes

1. Over-Reliance on Off-Chain data
2. Lack of On-Chain Verification

### Tools
### Refine
- [[1-Business_Logic]]
---
# Medium Risk Findings (xx)

---
## [M-03] Replace `createRetryableTicketNoRefundAliasRewrite()` with `depositEth()`
----
- **Tags**: #business_logic #arbitrum
- Number of finders: 3
- Difficulty: Medium 
---
### Description: 
The function `_startBridge()` of the `ArbitrumBridgeFacet` uses `createRetryableTicketNoRefundAliasRewrite()`. According to the docs: address-aliasing, this method skips some address rewrite magic that `depositEth()` does. 

Normally `depositEth()` should be used, according to the docs depositing-and-withdrawing-ether. Also this method will be deprecated after nitro: Inbox.sol#L283-L297. 

While the bridge doesn’t do these checks of `depositEth()`, it is easy for developers, that call the LiFi contracts directly, to make mistakes and loose tokens.

```solidity
function _startBridge(...) ... {
	... if (LibAsset.isNativeAsset(_bridgeData.assetId)) {
			gatewayRouter.createRetryableTicketNoRefundAliasRewrite{ value: _amount + cost }(...); 
		} ... 
	... 
}
```
### Recommendation: 
Replace `createRetryableTicketNoRefundAliasRewrite()` with `depositEth()`. 
### Discussion

LiFi: In principle, retryable tickets can alternatively be used to deposit Ether; this could be preferable to the special eth-deposit message type if, e.g., more flexibility for the destination address is needed, or if one wants to trigger the fallback function on the L2 side. Reverted with PR #79. 

Spearbit: Verified.

### Notes & Impressions

- non-standard usage
- #arbitrum [address-aliasing](https://docs.arbitrum.io/how-arbitrum-works/l1-to-l2-messaging#address-aliasing)

### Tools
### Refine

- [[1-Business_Logic]]

---
## [M-9] What if the receiver of Axelar `_executeWithToken()` doesn’t claim all tokens
----
- **Tags**: #business_logic #funds-locked 
- Number of finders: 3
- Difficulty: Medium
---
### Description: 

The function `_executeWithToken()` approves tokens and then calls `callTo`. If that contract doesn’t retrieve the tokens then the tokens stay within the `Executor` and are lost. Also see: "Remaining tokens can be swept from the LiFi Diamond or the Executor"

```solildity
contract Executor is IAxelarExecutable, Ownable, ReentrancyGuard, ILiFi {
    function _executeWithToken( ... ) ... {
		...
        // transfer received tokens to the recipient
        IERC20(tokenAddress).approve(callTo, amount);

        (bool success, ) = callTo.call(callData);
        ...
    }
}
```
### Recommended Mitigation

Consider sending the remaining tokens to a recovery address. 
### Discussion

### Notes & Impressions

##### Problematic Case

Now, suppose callTo has a bug and only claims 60 USDC instead of the full 100 USDC. Here’s how it plays out:

- The Executor approves 100 USDC to callTo.
- The call to callTo succeeds, and callTo transfers 60 USDC from the Executor to itself.
- After the call:
    - 60 USDC is with callTo.
    - 40 USDC remains in the Executor, still approved to callTo.
- Since `_executeWithToken`() doesn’t check or move the remaining 40 USDC, those tokens are stuck in the Executor with no way to recover them.

#### Impressions

- Incomplete token transfers
- Missing recovery mechanisms

### Tools
### Refine

- [[1-Business_Logic]]
- [[30-Fund_Lock]]

---
## [M-10] Remaining tokens can be swept from the LiFi Diamond or the Executor
----
- **Tags**: #business_logic 
- Number of finders: 3
- Difficulty: Medium
---
### Detail

The initial balance of (native) tokens in both the `Lifi Diamond` and the `Executor` contract can be swept by all the swap functions in all the bridges, which use the following functions:
- `swapAndCompleteBridgeTokensViaStargate()` of `Executor.sol `
- `swapAndCompleteBridgeTokens()` of `Executor.sol` 
- `swapAndExecute()` of `Executor.sol` 
- `_executeAndCheckSwaps()` of `SwapperV2.sol `
- `_executeAndCheckSwaps()` of `Swapper.sol` 
- `swapAndCompleteBridgeTokens()` of `XChainExecFacet `

Although these functions ... 
- `swapAndCompleteBridgeTokensViaStargate()` of `Executor.sol` 
- `swapAndCompleteBridgeTokens()` of `Executor.sol` 
- `swapAndExecute()` of `Executor.sol `
- `swapAndCompleteBridgeTokens()` of `XChainExecFacet`

have the following code:

```solidity
	if (!LibAsset.isNativeAsset(transferredAssetId)) { 
		startingBalance = LibAsset.getOwnBalance(transferredAssetId); 
		// sometimes transfer tokens in 
	} else { 
		startingBalance = LibAsset.getOwnBalance(transferredAssetId) - msg.value; 
	} 
	// do swaps 
	uint256 postSwapBalance = LibAsset.getOwnBalance(transferredAssetId); 
	if (postSwapBalance > startingBalance) { 
		LibAsset.transferAsset(transferredAssetId, receiver, postSwapBalance - startingBalance); 
	}
```

This doesn’t protect the initial balance of the first tokens, because it can just be part of a swap to another token. The initial balances of intermediate tokens are not checked or protected. 

As there normally shouldn’t be (native) tokens in the LiFi Diamond or the `Executor` the risk is limited. Note: set the risk to medium as there are other issues in this report that leave tokens in the contracts 

Although in practice there is some dust in the LiFi Diamond and the `Executor`.
### Recommended Mitigation

Consider whether any tokens left in the LiFi Diamond and the Executor should be taken into account.
- If so: for every (intermediate) swap determine initial amount of (native) token and make sure this isn’t swapped. 
- If not: remove the code with the `startingBalance`. also analyze all occurrences of tokens in the LiFi Diamond and the `Executor` to determine its source.

### Discussion

### Notes & Impressions

```
Initial Contract State:
- Executor Contract Balance: 100 USDC
- Expected Behavior: This balance should be protected

Malicious Swap Transaction:
1. Read Starting Balance: 100 USDC ✓
2. Perform Swap: Uses entire 100 USDC ❌
3. Post-Swap Balance Check: Allows transfer of 100 USDC ❌

Result:
- Initial 100 USDC is completely swept from the contract
- No safeguards prevent this unexpected token movement
```
#### Impressions

Initial Balance Protection
- Always explicitly define and protect initial contract balances
- Implement strict checks to prevent using pre-existing funds in transaction logic
- Create clear demarcation between initial contract funds and transaction-specific funds
### Tools
### Refine

- [[1-Business_Logic]]
---
## [M-12] Facets approve arbitrary addresses for ERC20 tokens
----
- **Tags**: #business_logic #bypass_limit #Diamond
- Number of finders: 3
- Difficulty: Medium
---
### Detail

All the facets pointed above approve an address for an ERC20 token, where both these values are provided by the user:

```solidity
LibAsset.maxApproveERC20(IERC20(token), router, amount);
```

The parameter names change depending on the context. So for any ERC20 token that `LifiDiamond` contract holds, user can: 
- call any of the functions in these facets to approve another address for that token. 
- use the approved address to transfer tokens out of `LifiDiamond` contract. 
Note: normally there shouldn’t be any tokens in the LiFi Diamond contract so the risk is limited. 
Note: also see "Hardcode bridge addresses via immutable"
### Recommended Mitigation

For each bridge facet, the bridge approval contract address is already known. Store these addresses in an `immutable` or a storage variable instead of taking it as a user input. Only approve and interact with these pre-defined addresses.

Example:

`AcrossFacet.sol`
```solidity
contract AcrossFacet is ILiFi, ReentrancyGuard, SwapperV2 {
+   IAcrossSpokePool private immutable spokePool;
	...
        else {
-          LibAsset.maxApproveERC20(IERC20(_acrossData.token), _acrossData.spokePool, _acrossData.amount);
+          LibAsset.maxApproveERC20(IERC20(_acrossData.assetId), address(spokePool), _acrossData.amount);
	    }
	    ...
}
```

`AmarokFacet.sol`
```solidity
contract AmarokFacet is ILiFi, ReentrancyGuard, SwapperV2 {
+   IConnextHandler private immutable connextHandler;
...
-        LibAsset.maxApproveERC20(IERC20(_bridgeData.assetId), _bridgeData.connextHandler, _amount);
-        IConnextHandler(_bridgeData.connextHandler).xcall(xcallArgs);
+        LibAsset.maxApproveERC20(IERC20(_bridgeData.assetId), address(connextHandler), _amount);
+        connextHandler.xcall(xcallArgs);
...
```

### Discussion

### Notes & Impressions

#### Notes 
the contract allows users to:

1. Specify an arbitrary ERC20 token
2. Specify an arbitrary router/bridge address
3. Approve that address to spend tokens from the contract

#### Impressions

1. User-controlled Address Inputs
2. Unchecked Token Interactions

*Never trust user-provided addresses for critical financial operations. Always maintain strict, predefined paths for token movements and approvals.*
### Tools
### Refine
- [[1-Business_Logic]]
- [[31-Diamond]]
- [[32-Bypass_limit]]

---
## Audit Summary Notes
- {{summary_notes}}

## Tags
- Category: {{tags_category}}
- Priority:{{tags_priority}}