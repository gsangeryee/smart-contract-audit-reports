# 2023-01-Ajna
---
- Category: #Dexes #CDP #services #Launchpad #Synthetics
- Note Create 2025-01-17
- Platform: sherlock
- Report Url: [2023-01-Ajna](https://audits.sherlock.xyz/contests/32?filter=results)
---
# High Risk Findings (xx)

---
## [H-07] ERC721Pool's `mergeOrRemoveCollateral` allows to remove collateral while auction is clearable
----
- **Tags**:  #business_logic 
- Number of finders: 1
- Difficulty: Medium
---
### Summary

User facing `mergeOrRemoveCollateral()` can effectively remove collateral, but lacks `_revertIfAuctionClearable()` check, i.e. allows to remove it while auction wasn't cleared.
### Detail

`mergeOrRemoveCollateral()` can remove collateral funds from the pool with `_transferFromPoolToAddress()` when the amount requested has been merged. As settling the auction can alter the collateral in some buckets its removal is generally restricted in the protocol when auction wasn't yet cleared.

Either way it is a gain for some LP at the expense of the others and a distribution based on a stale pool state (i.e. without auction result). As `mergeOrRemoveCollateral()` can be called by a lender at will an attacker will use it exactly when it is beneficial, at the expense of other participants.

Due to that setting the severity to be high as auctions are regular and so there is no low probability prerequisites.

`mergeOrRemoveCollateral()` allows for removing a collateral when the auction is clearable:

[ERC721Pool.sol#L280-L322](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L280-L322)
```solidity
    function mergeOrRemoveCollateral(
        uint256[] calldata removalIndexes_,
        uint256 noOfNFTsToRemove_,
        uint256 toIndex_
    ) external override nonReentrant returns (uint256 collateralMerged_, uint256 bucketLPs_) {
        PoolState memory poolState = _accruePoolInterest();
        uint256 collateralAmount = Maths.wad(noOfNFTsToRemove_);

        (
            collateralMerged_,
            bucketLPs_
        ) = LenderActions.mergeOrRemoveCollateral(
            buckets,
            deposits,
            removalIndexes_,
            collateralAmount,
            toIndex_
        );

        emit MergeOrRemoveCollateralNFT(msg.sender, collateralMerged_, bucketLPs_);

        // update pool interest rate state
        _updateInterestState(poolState, _lup(poolState.debt));

        if (collateralMerged_ == collateralAmount) {
            // Total collateral in buckets meets the requested removal amount, noOfNFTsToRemove_
            _transferFromPoolToAddress(msg.sender, bucketTokenIds, noOfNFTsToRemove_);
        }

    }

    /**
     *  @inheritdoc IPoolLenderActions
     *  @dev write state:
     *          - update bucketTokenIds arrays
     *  @dev emit events:
     *          - RemoveCollateral
     */
    function removeCollateral(
        uint256 noOfNFTsToRemove_,
        uint256 index_
    ) external override nonReentrant returns (uint256 collateralAmount_, uint256 lpAmount_) {
        _revertIfAuctionClearable(auctions, loans);
```

`_revertIfAuctionClearable()` checks whether pool state is ready to be altered by a result of the current auction:

[RevertsHelper.sol#L47-L59](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/helpers/RevertsHelper.sol#L47-L59)
```solidity
    function _revertIfAuctionClearable(
        AuctionsState storage auctions_,
        LoansState    storage loans_
    ) view {
        address head     = auctions_.head;
        uint256 kickTime = auctions_.liquidations[head].kickTime;
        if (kickTime != 0) {
            if (block.timestamp - kickTime > 72 hours) revert AuctionNotCleared();

            Borrower storage borrower = loans_.borrowers[head];
            if (borrower.t0Debt != 0 && borrower.collateral == 0) revert AuctionNotCleared();
        }
    }
```
### Recommended Mitigation

Consider adding the check:

```solidity
    function mergeOrRemoveCollateral(
        uint256[] calldata removalIndexes_,
        uint256 noOfNFTsToRemove_,
        uint256 toIndex_
    ) external override nonReentrant returns (uint256 collateralMerged_, uint256 bucketLPs_) {
+       _revertIfAuctionClearable(auctions, loans);
        PoolState memory poolState = _accruePoolInterest();
        uint256 collateralAmount = Maths.wad(noOfNFTsToRemove_);
```

### Discussion

### Notes

The key point of this findings is that we should ensure that all necessary requirements are met before any critical process, especially those involving finance.

### Tools
### Refine

- [[1-Business_Logic]]

---

---

# Medium Risk Findings (xx)

---
## [M-04] Incorrect MOMP calculation in neutral price calculation
----
- **Tags**: #wrong_math #business_logic 
- Number of finders: 1
- Difficulty: Hard
---
### Summary

When calculating MOMP to find the neutral price of a borrower, borrower's accrued debt is divided by the total number of loans in the pool, but it's total pool's debt that should be divided. The mistake will result in lower neutral prices and more lost bonds to kickers.
### Detail

As per the whitepaper:

>MOMP: is the price at which the amount of deposit above it is equal to the average loan size of the pool. MOMP is short for “Most Optimistic Matching Price”, as it’s the price at which a loan of average size would match with the most favorable lenders on the book.

I.e. MOMP is calculated on the total number of loans of a pool (so that the average loan size could be found).

MOMP calculation is [implemented correctly when kicking a debt](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L799), however it's implementation in the [Loans.update](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/internal/Loans.sol#L76) function is not correct:

```solidity
uint256 loansInPool = loans_.loans.length - 1 + auctions_.noOfAuctions;
uint256 curMomp     = _priceAt(Deposits.findIndexOfSum(deposits_, Maths.wdiv(borrowerAccruedDebt_, loansInPool * 1e18)));
```

Here, only borrower's debt (`borrowerAccruedDebt_`) is divided, not the entire debt of the pool.
### Impact

The miscalculation affects only borrower's neutral price calculation. Since MOMP is calculated on a smaller debt (borrower's debt will almost always be smaller than total pool's debt), the value of MOMP will be smaller than expected, and the neutral price will also be smaller (from the whitepaper: "The NP of a loan is the interest-adjusted MOMP..."). This will cause kickers to lose their bonds more often than expected, as per the whitepaper:

> If the liquidation auction yields a value that is over the “Neutral Price,” NP, the kicker forfeits a portion or all of their bond.
### Recommended Mitigation

Consider using total pool's debt in the MOMP calculation in `Loans.update`.
### Discussion

### Notes & Impressions

#### Impressions

Check financial calculation 
- Error Type: Part for Whole
### Tools
### Refine

- [[1-Business_Logic]]
- [[3-Wrong_Math]]

---
## [M-08] Claiming accumulated rewards while the contract is underfunded can lead to a loss of rewards
----
- **Tags**: #business_logic 
- Number of finders: 3
- Difficulty: Medium
---
### Summary

The claimable rewards for an NFT staker are capped at the Ajna token balance at the time of claiming. This can lead to a loss of rewards if the `RewardsManager` contract is underfunded with Ajna tokens.
### Detail

The `RewardsManager` contract keeps track of the rewards earned by an NFT staker. The accumulated rewards are claimed by calling the `RewardsManager.claimRewards` function. Internally, the `RewardsManager._claimRewards` function transfers the accumulated rewards to the staker.

However, the transferrable amount of Ajna token rewards are capped at the Ajna token balance at the time of claiming. If the accumulated rewards are higher than the Ajna token balance, the claimer will receive fewer rewards than expected. The remaining rewards cannot be claimed at a later time as the `RewardsManager` contract does not keep track of the rewards that were not transferred.

[RewardsManager.sol#L479](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L479)
```solidity
445: function _claimRewards(
446:     uint256 tokenId_,
447:     uint256 epochToClaim_
448: ) internal {
         // [...]

477:     uint256 ajnaBalance = IERC20(ajnaToken).balanceOf(address(this));
478:
479:     if (rewardsEarned > ajnaBalance) rewardsEarned = ajnaBalance;
480:
481:     // transfer rewards to sender
482:     IERC20(ajnaToken).safeTransfer(msg.sender, rewardsEarned);
483: }
```
### Impact

If an NFT staker claims the accumulated rewards in a bad situation (when the `RewardsManager` contract is underfunded with Ajna tokens), the staker will receive fewer rewards than expected and is unable to claim the rest of the rewards at a later time.
### Recommended Mitigation

Consider reverting if insufficient Ajna tokens are available as rewards.

### Discussion

### Notes & Impressions

#### Notes 
The problem occurs in the _claimRewards function. When a user tries to claim their rewards, the contract does this:

1. First, it calculates how many rewards the user has earned (let's say 1000 tokens)
2. Then it checks the actual balance of Ajna tokens in the contract
3. If the balance is lower than the earned rewards (say 600 tokens), it simply reduces the rewards to match the available balance
4. The contract then transfers this reduced amount
5. Crucially, it doesn't keep track of the unclaimed portion (the remaining 400 tokens in our example)
#### Impressions

*Unfairly capped rewards*


### Tools
### Refine

- [[1-Business_Logic]]
---
## [M-16] Auction timers following liquidity can fall through the floor price causing pool insolvency
----
- **Tags**: #lending_pool #business_logic #auction
- Number of finders: 1
- Difficulty: Medium
---
### Summary

When a borrower cannot pay their debt in an ERC20 pool, their position is liquidated and their assets enter an auction for other users to purchase small pieces of their assets. Because of the incentive that users wish to not pay above the standard market price for a token, users will generally wait until assets on auction are as cheap as possible to purchase however, this is flawed because this guarantees a loss for all lenders participating in the protocol with each user that is liquidated.

### Detail

Consider a situation where a user decides to short a coin through a loan and refuses to take the loss to retain the value of their position. When the auction is kicked off using the `kick()` function on this user, as time moves forward, the price for puchasing these assets becomes increasingly cheaper. These prices can fall through the floor price of the lending pool which will allow anybody to buy tokens for only a fraction of what they were worth originally leading to a state where the pool cant cover the debt of the user who has not paid their loan back with interest. The issue lies in the `_auctionPrice()` function of the `Auctions.sol` contract which calculates the price of the auctioned assets for the taker. 

[Auctions.sol#L1390-L1411](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L1390-L1411)
```solidity
    /**
     *  @notice Calculates auction price.
     *  @param  kickMomp_     MOMP recorded at the time of kick.
     *  @param  neutralPrice_ Neutral Price of the auction.
     *  @param  kickTime_     Time when auction was kicked.
     *  @return price_        Calculated auction price.
     */
    function _auctionPrice(
        uint256 kickMomp_,
        uint256 neutralPrice_,
        uint256 kickTime_
    ) internal view returns (uint256 price_) {
        uint256 elapsedHours = Maths.wdiv((block.timestamp - kickTime_) * 1e18, 1 hours * 1e18);


        elapsedHours -= Maths.min(elapsedHours, 1e18);  // price locked during cure period


        int256 timeAdjustment  = PRBMathSD59x18.mul(-1 * 1e18, int256(elapsedHours)); 
        uint256 referencePrice = Maths.max(kickMomp_, neutralPrice_); 


        price_ = 32 * Maths.wmul(referencePrice, uint256(PRBMathSD59x18.exp2(timeAdjustment)));
    }


```

This function does not consider the floor price of the pool. The proof of concept below outlines this scenario:

```solidity
    function testInsolvency() public {
        
        // ============== Setup Scenario ==============
        uint256 interestRateOne = 0.05 * 10**18;           // Collateral  // Quote (loaned token, short position)
        address poolThreeAddr = erc20PoolFactory.deployPool(address(dai), address(weth), interestRateOne);
        ERC20Pool poolThree = ERC20Pool(address(poolThreeAddr));
        vm.label(poolThreeAddr, "DAI / WETH Pool Three");

        // Setup scenario and send liquidity providers some tokens
        vm.startPrank(address(daiDoner));
        dai.transfer(address(charlie), 3200 ether);
        vm.stopPrank();

        vm.startPrank(address(wethDoner));
        weth.transfer(address(bob), 1000 ether);
        vm.stopPrank();

        // ==============================================


        // Note At the time (24/01/2023) of writing ETH is currently 1,625.02 DAI,
        // so this would be a popular bucket to deposit in.

        // Start Scenario
        // The lower dowm we go the cheaper wETH becomes - At a concentrated fenwick index of 5635, 1 wETH = 1600 DAI (Approx real life price)
        uint256 fenwick = 5635; // This index represents price where 1 WETH = 1600 DAI

        vm.startPrank(address(alice));
        weth.deposit{value: 2 ether}();
        weth.approve(address(poolThree), 2.226 ether);
        poolThree.addQuoteToken(2 ether, fenwick); 
        vm.stopPrank();

        vm.startPrank(address(bob));
        weth.deposit{value: 9 ether}();
        weth.approve(address(poolThree), 9 ether);
        poolThree.addQuoteToken(9 ether, fenwick); 
        vm.stopPrank();

        assertEq(weth.balanceOf(address(poolThree)), 11 ether);


        // ======================== start testing ========================

        vm.startPrank(address(bob));
        bytes32 poolSubsetHashes = keccak256("ERC20_NON_SUBSET_HASH");
        IPositionManagerOwnerActions.MintParams memory mp = IPositionManagerOwnerActions.MintParams({
            recipient: address(bob),
            pool: address(poolThree),
            poolSubsetHash: poolSubsetHashes
        });
        positionManager.mint(mp);
        positionManager.setApprovalForAll(address(rewardsManager), true);
        rewardsManager.stake(1);
        vm.stopPrank();


        assertEq(dai.balanceOf(address(charlie)), 3200 ether);
        vm.startPrank(address(charlie)); // Charlie runs away with the weth tokens
        dai.approve(address(poolThree), 3200 ether);
        poolThree.drawDebt(address(charlie), 2 ether, fenwick, 3200 ether);
        vm.stopPrank();

        vm.warp(block.timestamp + 62 days); // Time passes


        vm.startPrank(address(bob));
        weth.deposit{value: 0.5 ether}();
        weth.approve(address(poolThree), 0.5 ether);
        poolThree.kick(address(charlie)); // Kick off liquidation
        vm.stopPrank();

        vm.warp(block.timestamp + 10 hours); // More time passes

        assertEq(weth.balanceOf(address(poolThree)), 9020189981190878108); // 9 ether


        vm.startPrank(address(bob));
        // Bob Takes a (pretend) flashloan of 1000 weth to get cheap dai tokens
        // Bob uses a large amount of WETH to take advantage of the low prices
        weth.approve(address(poolThree), 1000 ether);
        poolThree.take(address(charlie), 1000 ether , address(bob), "");
        // Multiple takes to acquire the assets at very low prices
        weth.approve(address(poolThree), 1000 ether);
        poolThree.take(address(charlie), 1000 ether , address(bob), "");
        weth.approve(address(poolThree), 1000 ether);
        poolThree.take(address(charlie), 1000 ether , address(bob), "");
        weth.approve(address(poolThree), 1000 ether);
        poolThree.take(address(charlie), 1000 ether, address(bob), "");
        
        poolThree.settle(address(charlie), 100);
        vm.stopPrank();


        assertEq(weth.balanceOf(address(poolThree)), 9152686732755985308); // Pool balance is still 9 ether instead of 11 ether - insolvency. 
        assertEq(dai.balanceOf(address(bob)), 3200 ether); // The original amount that charlie posted as deposit


        vm.warp(block.timestamp + 2 hours);
        // users attempt to withdraw after shaken by a liquidation
        vm.startPrank(address(alice));
        poolThree.removeQuoteToken(2 ether, fenwick);
        vm.stopPrank();

        vm.startPrank(address(bob));
        poolThree.removeQuoteToken(9 ether, fenwick);
        vm.stopPrank();

        assertEq(weth.balanceOf(address(bob)), 1007664981389220443074); // 1007 ether, originally 1009 ether
        assertEq(weth.balanceOf(address(alice)), 1626148471550317418); // 1.6 ether, originally 2 ether

    }
```
### Impact

An increase in borrowers who cant pay their debts back will result in a loss for all lenders.
### Recommended Mitigation

It's recommended that the price of the assets on auction consider the fenwick(s) being used when determining the price of assets on loan and do not fall below that particular index. With this fix in place, the worst case scenario is that lenders can pruchase these assets for the price they were loaned out for allowing them to recover the loss.

### Discussion

**grandizzy**

this is a design choice. however we're reconsidering the auction implementation to use a floor price

**hrishibhat**

Considering this issue a valid medium as there is a possible risk of funds lost for lenders under certain circumstances

### Notes & Impressions

The lack of a minimum price floor in the liquidation auction mechanism

1. Current Design:

- Auction prices decrease exponentially with time
- No lower bound on how low prices can go
- Allows purchasers to buy collateral far below market value

### Tools
### Refine

- [[1-Business_Logic]]

---
## [M-22] Memorializing an NFT position on the same bucket of a previously memorialized NFT locks redemption
----
- **Tags**: #mapping #business_logic 
- Number of finders: 1
- Difficulty: Hard
---
### Summary

Memorializing a position as an NFT on the same bucket of an existing memorialized position will not allow any of the owners to directly redeem it back later.

### Vulnerability Detail

This issue happens because, after a position is memorialized on the `PositionManager`, this contract will centralize LP positions from different users, but these will be mapped to the same address from the point of view of Ajna pools (different users will be mapped as the same `lender` from the point of view of a `Pool`).

If more than one user has memorialized a position to the same bucket index, when attempting to `PositionManager.redeemPositions`, the call to `pool.transferLPs` will revert with `NoAllowance`, as `LenderActions` does not allow a transfer with value lower than the total `lenderLpBalance`.

[pool.transferLPs](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/PositionManager.sol#L311)
```solidity
    function reedemPositions(
        RedeemPositionsParams calldata params_
    ) external override mayInteract(params_.pool, params_.tokenId) {
    ... ...
        // update pool lp token accounting and transfer ownership of lp tokens from PositionManager contract
        pool.transferLPs(address(this), owner, params_.indexes);
    }
```

[NoAllowance](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/LenderActions.sol#L538)
```solidity
    function transferLPs(
        mapping(uint256 => Bucket) storage buckets_,
        mapping(address => mapping(address => mapping(uint256 => uint256))) storage allowances_,
        address owner_,
        address newOwner_,
        uint256[] calldata indexes_
    ) external {
... ...

            if (transferAmount == 0 || transferAmount != lenderLpBalance) revert NoAllowance();

... ...
}
```

Because of that, any of the users' that share a bucket `redeemPositions` calls will fail.

### Impact

Although users that share a bucket with memorialized positions are not able to direct redeem their positions, they can eventually get their LPs back with a specific set of actions.

By first calling `PositionManager.moveLiquidity` to a bucket _without any other LPs_ managed by `PositionsManager` (since `LenderActions.moveQuoteToken` accepts moving less liquidity than the total a LP balance for a specific bucket), and then calling `PositionManager.redeemPositions`, LP-ers will be able to redeem their positions back. Because of this possibility, this is a Medium-severity issue.

```solidity
diff --git a/contracts/tests/forge/PositionManager.t.sol b/contracts/tests/forge/PositionManager.t.sol
index 5e691fc..5d5e822 100644
--- a/contracts/tests/forge/PositionManager.t.sol
+++ b/contracts/tests/forge/PositionManager.t.sol
@@ -186,6 +186,91 @@ contract PositionManagerERC20PoolTest is PositionManagerERC20PoolHelperContract
         assertTrue(_positionManager.isIndexInPosition(tokenId, 2552));
     }
 
+    function testMemorializePositionsTwoAccountsSameBucket() external {
+        address alice = makeAddr("alice");
+        address bob = makeAddr("bob");
+        uint256 mintAmount  = 10_000 * 1e18;
+
+        uint256 lpBalance;
+        uint256 depositTime;
+
+        _mintQuoteAndApproveManagerTokens(alice, mintAmount);
+        _mintQuoteAndApproveManagerTokens(bob, mintAmount);
+
+        // call pool contract directly to add quote tokens
+        uint256[] memory indexes = new uint256[](1);
+        indexes[0] = 2550;
+
+        // alice adds liquidity now
+        _addInitialLiquidity(
+            {
+                from:   alice,
+                amount: 3_000 * 1e18,
+                index:  indexes[0]
+            }
+        );
+        (lpBalance, depositTime) = _pool.lenderInfo(indexes[0], alice);
+        uint256 aliceDepositTime = block.timestamp;
+        assertEq(lpBalance, 3_000 * 1e27);
+        assertEq(depositTime, aliceDepositTime);
+
+        // bob adds liquidity later
+        skip(1 hours);
+        _addInitialLiquidity(
+            {
+                from:   bob,
+                amount: 3_000 * 1e18,
+                index:  indexes[0]
+            }
+        );
+        (lpBalance, depositTime) = _pool.lenderInfo(indexes[0], bob);
+        assertEq(lpBalance, 3_000 * 1e27);
+        assertEq(depositTime, aliceDepositTime + 1 hours);
+
+
+        // bob memorializes first, alice memorializes second
+        address[] memory addresses = new address[](2);
+        addresses[0] = bob;
+        addresses[1] = alice;
+        uint256[] memory tokenIds = new uint256[](2);
+
+        // bob and alice mint an NFT to later memorialize existing positions into
+        tokenIds[0] = _mintNFT(bob, bob, address(_pool));
+        assertFalse(_positionManager.isIndexInPosition(tokenIds[0], 2550));
+        tokenIds[1] = _mintNFT(alice, alice, address(_pool));
+        assertFalse(_positionManager.isIndexInPosition(tokenIds[1], 2550));
+
+        for(uint256 i = 0; i < addresses.length; ++i) {
+            // construct memorialize params struct
+            IPositionManagerOwnerActions.MemorializePositionsParams memory memorializeParams = IPositionManagerOwnerActions.MemorializePositionsParams(
+                tokenIds[i], indexes
+            );
+
+            // allow position manager to take ownership of the position
+            changePrank(addresses[i]);
+            _pool.approveLpOwnership(address(_positionManager), indexes[0], 3_000 * 1e27);
+
+            // memorialize quote tokens into minted NFT
+            vm.expectEmit(true, true, true, true);
+            emit MemorializePosition(addresses[i], tokenIds[i]);
+            vm.expectEmit(true, true, true, true);
+            emit TransferLPTokens(addresses[i], address(_positionManager), indexes, 3_000 * 1e27);
+
+            _positionManager.memorializePositions(memorializeParams);
+        }
+
+        // now both redeem
+        // will revert
+        for(uint256 i = 0; i < addresses.length; ++i) {
+            // construct memorialize params struct
+            IPositionManagerOwnerActions.RedeemPositionsParams memory params = IPositionManagerOwnerActions.RedeemPositionsParams(
+                tokenIds[i], address(_pool), indexes
+            );
+            changePrank(addresses[i]);
+            _positionManager.reedemPositions(params);
+        }
+    }
+
     function testRememorializePositions() external {
         address testAddress = makeAddr("testAddress");
         uint256 mintAmount  = 50_000 * 1e18;

```

### Recommendation

There are some possible alternatives to solving this issue.

1. Allow `LenderActions.transferLPs` to transfer an amount different than the total LP balance. Appropriate care must be taken with [approve/transfer](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#) [attack vectors](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#), that do not exist now as approvals are always exact and cleared after every transfer, but they may become important if the this flow is refactored.
    
2. Reconsider the `PositionsManager` architecture and the way the LP balances are stored on the Ajna protocol. Since positions are not tokenized by default, but instead are stored on state variables on each pool, it is arguably more complex to reason about transferring positions between two users. Conversely, the ERC-20 and ERC-721 standards already provide straightforward methods for minting/burning/sending tokens for accounts. A suggestion is, for example, to remove the optionality of NFT minting through another independent contract (the `PositionManager.sol`), and instead to refactor the Ajna pools so that every position is an ERC-721 NFT minted directly by the `Pool.sol`.
### Discussion

### Notes & Impressions

Real-World Analogy: Think of a bank where you can deposit money into different types of savings accounts (these are like the "buckets" in the protocol). The bank offers a special service where you can convert your savings account into a commemorative coin (like the NFT). The catch is that the bank has a rule that you can only withdraw the entire amount in an account at once.

Now let's look at what happens in the smart contract with actual examples:

Example Scenario 1 - The Normal Case:

```
// Alice deposits 3000 tokens into bucket #2550
Alice -> Bucket #2550: 3000 tokens
// Alice memorializes this into NFT #1
Alice's NFT #1 represents: 3000 tokens in bucket #2550
// Alice can successfully redeem later
Alice redeems NFT #1 -> Gets back 3000 tokens
```


Example Scenario 2 - The Problem Case:

```
// First, Alice deposits
Alice -> Bucket #2550: 3000 tokens
// Then Bob also deposits in the same bucket
Bob -> Bucket #2550: 3000 tokens

// Now they both memorialize their positions
Alice's NFT #1 represents: 3000 tokens in bucket #2550
Bob's NFT #2 represents: 3000 tokens in bucket #2550

// Problem occurs when trying to redeem:
Alice tries to redeem NFT #1 -> FAILS!
Bob tries to redeem NFT #2 -> FAILS!
```

Why does it fail? Because from the pool's perspective, the PositionManager now looks like this:

```
Bucket #2550:
  Total Balance: 6000 tokens
  Owner: PositionManager
```

When Alice tries to withdraw 3000 tokens, the contract says "Sorry, you must withdraw all 6000 tokens or nothing at all!" But Alice's NFT only gives her the right to 3000 tokens, not all 6000.

#### Impressions

Error Type: Part Vs Whole
### Tools
### Refine

- [[1-Business_Logic]]

---

## Audit Summary Notes
- {{summary_notes}}

## Tags
- Category: {{tags_category}}
- Priority:{{tags_priority}}