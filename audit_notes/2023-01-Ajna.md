# 2023-01-Ajna
---
- Category: #Dexes #CDP #services #Launchpad #Synthetics
- Note Create 2025-01-17
- Platform: sherlock
- Report Url: [2023-01-Ajna](https://audits.sherlock.xyz/contests/32?filter=results)
---
# High Risk Findings (xx)

---
## [H-07] ERC721Pool's `mergeOrRemoveCollateral` allows to remove collateral while auction is clearable
----
- **Tags**:  #business_logic 
- Number of finders: 1
- Difficulty: Medium
---
### Summary

User facing `mergeOrRemoveCollateral()` can effectively remove collateral, but lacks `_revertIfAuctionClearable()` check, i.e. allows to remove it while auction wasn't cleared.
### Detail

`mergeOrRemoveCollateral()` can remove collateral funds from the pool with `_transferFromPoolToAddress()` when the amount requested has been merged. As settling the auction can alter the collateral in some buckets its removal is generally restricted in the protocol when auction wasn't yet cleared.

Either way it is a gain for some LP at the expense of the others and a distribution based on a stale pool state (i.e. without auction result). As `mergeOrRemoveCollateral()` can be called by a lender at will an attacker will use it exactly when it is beneficial, at the expense of other participants.

Due to that setting the severity to be high as auctions are regular and so there is no low probability prerequisites.

`mergeOrRemoveCollateral()` allows for removing a collateral when the auction is clearable:

[ERC721Pool.sol#L280-L322](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L280-L322)
```solidity
    function mergeOrRemoveCollateral(
        uint256[] calldata removalIndexes_,
        uint256 noOfNFTsToRemove_,
        uint256 toIndex_
    ) external override nonReentrant returns (uint256 collateralMerged_, uint256 bucketLPs_) {
        PoolState memory poolState = _accruePoolInterest();
        uint256 collateralAmount = Maths.wad(noOfNFTsToRemove_);

        (
            collateralMerged_,
            bucketLPs_
        ) = LenderActions.mergeOrRemoveCollateral(
            buckets,
            deposits,
            removalIndexes_,
            collateralAmount,
            toIndex_
        );

        emit MergeOrRemoveCollateralNFT(msg.sender, collateralMerged_, bucketLPs_);

        // update pool interest rate state
        _updateInterestState(poolState, _lup(poolState.debt));

        if (collateralMerged_ == collateralAmount) {
            // Total collateral in buckets meets the requested removal amount, noOfNFTsToRemove_
            _transferFromPoolToAddress(msg.sender, bucketTokenIds, noOfNFTsToRemove_);
        }

    }

    /**
     *  @inheritdoc IPoolLenderActions
     *  @dev write state:
     *          - update bucketTokenIds arrays
     *  @dev emit events:
     *          - RemoveCollateral
     */
    function removeCollateral(
        uint256 noOfNFTsToRemove_,
        uint256 index_
    ) external override nonReentrant returns (uint256 collateralAmount_, uint256 lpAmount_) {
        _revertIfAuctionClearable(auctions, loans);
```

`_revertIfAuctionClearable()` checks whether pool state is ready to be altered by a result of the current auction:

[RevertsHelper.sol#L47-L59](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/helpers/RevertsHelper.sol#L47-L59)
```solidity
    function _revertIfAuctionClearable(
        AuctionsState storage auctions_,
        LoansState    storage loans_
    ) view {
        address head     = auctions_.head;
        uint256 kickTime = auctions_.liquidations[head].kickTime;
        if (kickTime != 0) {
            if (block.timestamp - kickTime > 72 hours) revert AuctionNotCleared();

            Borrower storage borrower = loans_.borrowers[head];
            if (borrower.t0Debt != 0 && borrower.collateral == 0) revert AuctionNotCleared();
        }
    }
```
### Recommended Mitigation

Consider adding the check:

```solidity
    function mergeOrRemoveCollateral(
        uint256[] calldata removalIndexes_,
        uint256 noOfNFTsToRemove_,
        uint256 toIndex_
    ) external override nonReentrant returns (uint256 collateralMerged_, uint256 bucketLPs_) {
+       _revertIfAuctionClearable(auctions, loans);
        PoolState memory poolState = _accruePoolInterest();
        uint256 collateralAmount = Maths.wad(noOfNFTsToRemove_);
```

### Discussion

### Notes

The key point of this findings is that we should ensure that all necessary requirements are met before any critical process, especially those involving finance.

### Tools
### Refine

- [[1-Business_Logic]]

---

---

# Medium Risk Findings (xx)

---
## [M-04] Incorrect MOMP calculation in neutral price calculation
----
- **Tags**: #wrong_math #business_logic 
- Number of finders: 1
- Difficulty: Hard
---
### Summary

When calculating MOMP to find the neutral price of a borrower, borrower's accrued debt is divided by the total number of loans in the pool, but it's total pool's debt that should be divided. The mistake will result in lower neutral prices and more lost bonds to kickers.
### Detail

As per the whitepaper:

>MOMP: is the price at which the amount of deposit above it is equal to the average loan size of the pool. MOMP is short for “Most Optimistic Matching Price”, as it’s the price at which a loan of average size would match with the most favorable lenders on the book.

I.e. MOMP is calculated on the total number of loans of a pool (so that the average loan size could be found).

MOMP calculation is [implemented correctly when kicking a debt](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L799), however it's implementation in the [Loans.update](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/internal/Loans.sol#L76) function is not correct:

```solidity
uint256 loansInPool = loans_.loans.length - 1 + auctions_.noOfAuctions;
uint256 curMomp     = _priceAt(Deposits.findIndexOfSum(deposits_, Maths.wdiv(borrowerAccruedDebt_, loansInPool * 1e18)));
```

Here, only borrower's debt (`borrowerAccruedDebt_`) is divided, not the entire debt of the pool.
### Impact

The miscalculation affects only borrower's neutral price calculation. Since MOMP is calculated on a smaller debt (borrower's debt will almost always be smaller than total pool's debt), the value of MOMP will be smaller than expected, and the neutral price will also be smaller (from the whitepaper: "The NP of a loan is the interest-adjusted MOMP..."). This will cause kickers to lose their bonds more often than expected, as per the whitepaper:

> If the liquidation auction yields a value that is over the “Neutral Price,” NP, the kicker forfeits a portion or all of their bond.
### Recommended Mitigation

Consider using total pool's debt in the MOMP calculation in `Loans.update`.
### Discussion

### Notes & Impressions

#### Impressions

Check financial calculation 
- Error Type: Part for Whole
### Tools
### Refine

- [[1-Business_Logic]]
- [[3-Wrong_Math]]

---
## [M-08] Claiming accumulated rewards while the contract is underfunded can lead to a loss of rewards
----
- **Tags**: #business_logic 
- Number of finders: 3
- Difficulty: Medium
---
### Summary

The claimable rewards for an NFT staker are capped at the Ajna token balance at the time of claiming. This can lead to a loss of rewards if the `RewardsManager` contract is underfunded with Ajna tokens.
### Detail

The `RewardsManager` contract keeps track of the rewards earned by an NFT staker. The accumulated rewards are claimed by calling the `RewardsManager.claimRewards` function. Internally, the `RewardsManager._claimRewards` function transfers the accumulated rewards to the staker.

However, the transferrable amount of Ajna token rewards are capped at the Ajna token balance at the time of claiming. If the accumulated rewards are higher than the Ajna token balance, the claimer will receive fewer rewards than expected. The remaining rewards cannot be claimed at a later time as the `RewardsManager` contract does not keep track of the rewards that were not transferred.

[RewardsManager.sol#L479](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L479)
```solidity
445: function _claimRewards(
446:     uint256 tokenId_,
447:     uint256 epochToClaim_
448: ) internal {
         // [...]

477:     uint256 ajnaBalance = IERC20(ajnaToken).balanceOf(address(this));
478:
479:     if (rewardsEarned > ajnaBalance) rewardsEarned = ajnaBalance;
480:
481:     // transfer rewards to sender
482:     IERC20(ajnaToken).safeTransfer(msg.sender, rewardsEarned);
483: }
```
### Impact

If an NFT staker claims the accumulated rewards in a bad situation (when the `RewardsManager` contract is underfunded with Ajna tokens), the staker will receive fewer rewards than expected and is unable to claim the rest of the rewards at a later time.
### Recommended Mitigation

Consider reverting if insufficient Ajna tokens are available as rewards.

### Discussion

### Notes & Impressions

#### Notes 
The problem occurs in the _claimRewards function. When a user tries to claim their rewards, the contract does this:

1. First, it calculates how many rewards the user has earned (let's say 1000 tokens)
2. Then it checks the actual balance of Ajna tokens in the contract
3. If the balance is lower than the earned rewards (say 600 tokens), it simply reduces the rewards to match the available balance
4. The contract then transfers this reduced amount
5. Crucially, it doesn't keep track of the unclaimed portion (the remaining 400 tokens in our example)
#### Impressions

*Unfairly capped rewards*


### Tools
### Refine

- [[1-Business_Logic]]
---
## [M-11] Settled collateral of a borrower aren't available for lenders until borrower's debt is fully cleared
----
- **Tags**: #Do_not_update_state #business_logic 
- Number of finders: 1
- Difficulty: Medium
---
### Summary

ERC721Pool's `settle()` lacks collateral ids array rebalance when the settlement isn't full, i.e. when `t0DebtRemaining > 0`.

### Vulnerability Detail

Auctions's `settlePoolDebt()` returns current state of the borrower after the settlement. If any of borrower's collateral `id` were removed from them it needs to be accounted for, but when `t0DebtRemaining > 0` this doesn't happen, i.e. removed borrower's tokens aren't added to the buckets cumulative collateral ids array and so this collateral is still unavailable for lenders.

### Impact

The settled collateral of the borrower will not be available for LP's withdrawal as the corresponding function will revert on an attempt to extract token ids from `bucketTokenIds` array.

The length of such freeze can vary up to be permanent, for example if there is no funds (reserves and deposits) to fully settle the borrower. This is principal fund loss scenario for the lenders, but given the prerequisite of the full default setting the severity to be medium.

## Code Snippet

When a borrower has some unsettled debt, `t0DebtRemaining > 0`, all of their collateral remain locked with `borrowerTokenIds` as `_rebalanceTokens()` isn't called in this case:

[ERC721Pool.sol#L353-L385](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L353-L385)
```solidity
    function settle(
        address borrowerAddress_,
        uint256 maxDepth_
    ) external nonReentrant override {
        PoolState memory poolState = _accruePoolInterest();

        uint256 assets = Maths.wmul(poolBalances.t0Debt, poolState.inflator) + _getPoolQuoteTokenBalance();
        uint256 liabilities = Deposits.treeSum(deposits) + auctions.totalBondEscrowed + reserveAuction.unclaimed;

        SettleParams memory params = SettleParams(
            {
                borrower:    borrowerAddress_,
                reserves:    (assets > liabilities) ? (assets-liabilities) : 0,
                inflator:    poolState.inflator,
                bucketDepth: maxDepth_,
                poolType:    poolState.poolType
            }
        );
        (
            uint256 collateralRemaining,
            uint256 t0DebtRemaining,
            uint256 collateralSettled,
            uint256 t0DebtSettled
        ) = Auctions.settlePoolDebt(
            auctions,
            buckets,
            deposits,
            loans,
            params
        );

        // slither-disable-next-line incorrect-equality
        if (t0DebtRemaining == 0) _rebalanceTokens(params.borrower, collateralRemaining);
```

This can happen when settlement exits when `params_.bucketDepth == 0`:

[Auctions.sol#L277-L337](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L277-L337)
```solidity
        // if there's still debt and no collateral
        if (borrower.t0Debt != 0 && borrower.collateral == 0) {
            // settle debt from reserves -- round reserves down however
            borrower.t0Debt -= Maths.min(borrower.t0Debt, (params_.reserves / params_.inflator) * 1e18);

            // if there's still debt after settling from reserves then start to forgive amount from next HPB
            // loop through remaining buckets if there's still debt to settle
            while (params_.bucketDepth != 0 && borrower.t0Debt != 0) {
                SettleLocalVars memory vars;

                (vars.index, , vars.scale) = Deposits.findIndexAndSumOfSum(deposits_, 1);
                vars.unscaledDeposit = Deposits.unscaledValueAt(deposits_, vars.index);
                vars.depositToRemove = Maths.wmul(vars.scale, vars.unscaledDeposit);
                vars.debt            = Maths.wmul(borrower.t0Debt, params_.inflator);

                // enough deposit in bucket to settle entire debt
                if (vars.depositToRemove >= vars.debt) {
                    Deposits.unscaledRemove(deposits_, vars.index, Maths.wdiv(vars.debt, vars.scale));
                    borrower.t0Debt  = 0;                                                              // no remaining debt to settle

                // not enough deposit to settle entire debt, we settle only deposit amount
                } else {
                    borrower.t0Debt -= Maths.wdiv(vars.depositToRemove, params_.inflator);             // subtract from remaining debt the corresponding t0 amount of deposit

                    Deposits.unscaledRemove(deposits_, vars.index, vars.unscaledDeposit);              // Remove all deposit from bucket
                    Bucket storage hpbBucket = buckets_[vars.index];
                    
                    if (hpbBucket.collateral == 0) {                                                   // existing LPB and LP tokens for the bucket shall become unclaimable.
                        emit BucketBankruptcy(vars.index, hpbBucket.lps);
                        hpbBucket.lps            = 0;
                        hpbBucket.bankruptcyTime = block.timestamp;
                    }
                }

                --params_.bucketDepth;
            }
        }

        t0DebtRemaining_ =  borrower.t0Debt;
        t0DebtSettled_   -= t0DebtRemaining_;

        emit Settle(params_.borrower, t0DebtSettled_);

        if (borrower.t0Debt == 0) {
            // settle auction
            borrower.collateral = _settleAuction(
                auctions_,
                buckets_,
                deposits_,
                params_.borrower,
                borrower.collateral,
                params_.poolType
            );
        }

        collateralRemaining_ =  borrower.collateral;
        collateralSettled_   -= collateralRemaining_;

        // update borrower state
        loans_.borrowers[params_.borrower] = borrower;
    }
```

### Recommended Mitigation

Consider rebalancing each time when there is something to rebalance, for example:

[ERC721Pool.sol#L353-L385](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L353-L385)
```solidity
    function settle(
        address borrowerAddress_,
        uint256 maxDepth_
    ) external nonReentrant override {
        ...
        (
            uint256 collateralRemaining,
            uint256 t0DebtRemaining,
            uint256 collateralSettled,
            uint256 t0DebtSettled
        ) = Auctions.settlePoolDebt(
            ...
        );

        // slither-disable-next-line incorrect-equality
-        if (t0DebtRemaining == 0) _rebalanceTokens(params.borrower, collateralRemaining);
+        if (collateralSettled > 0) _rebalanceTokens(params.borrower, collateralRemaining);
```
### Discussion

### Notes & Impressions

#### Notes 

```
Initial State:
Borrower Alice has 3 NFTs as collateral: [NFT#1, NFT#2, NFT#3]
borrowerTokenIds["Alice"] = [1, 2, 3]
bucketTokenIds = []

After Partial Settlement:
Alice still owes some debt, but 2 NFTs should be settled
Expected state should be:
borrowerTokenIds["Alice"] = [3]       // Alice keeps one NFT
bucketTokenIds = [1, 2]               // Two NFTs moved to bucket

But due to the bug, without rebalancing:
borrowerTokenIds["Alice"] = [1, 2, 3] // Alice's array unchanged
bucketTokenIds = []                   // Bucket array unchanged
```

The vulnerability arises because the code only performs this rebalancing when the debt is fully settled (`t0DebtRemaining == 0`). This means that in partial settlement cases, the tokens remain tracked in the borrower's array even though they should be available to lenders.
#### Impressions

1. Single-condition state updates (`if (x == 0)` rather than handling all cases)

This is exactly what we saw in the original vulnerability. The code only performed state updates in one specific case:
```solidity
if (t0DebtRemaining == 0) _rebalanceTokens(params.borrower, collateralRemaining);
```

This pattern is dangerous because it assumes operations are all-or-nothing. In reality, DeFi operations often have partial completions or intermediate states. A better approach handles all possible states. For example:
```solidity
// Good: Handle different states explicitly
if (t0DebtRemaining == 0) {
    // Handle full settlement
    _rebalanceTokens(params.borrower, 0);
} else if (collateralSettled > 0) {
    // Handle partial settlement
    _rebalanceTokens(params.borrower, collateralRemaining);
} else {
    // Handle no settlement
    emit SettlementFailed(params.borrower);
}
```

2. Asset transfers without corresponding state updates

This warning sign appears when tokens or assets move but accounting doesn't reflect the change. Let's look at a problematic example:
```solidity
// Dangerous: Transfer happens without updating internal accounting
function withdrawCollateral(uint256 tokenId) external {
    IERC721(collateralToken).transferFrom(address(this), msg.sender, tokenId);
    // Missing: updateUserCollateralBalance(msg.sender, tokenId);
    // Missing: removeTokenFromUserArray(msg.sender, tokenId);
}
```

A safer version would ensure all state variables are updated:
```solidity
function withdrawCollateral(uint256 tokenId) external {
    // Update state before transfer
    updateUserCollateralBalance(msg.sender, tokenId);
    removeTokenFromUserArray(msg.sender, tokenId);
    
    // Perform transfer
    IERC721(collateralToken).transferFrom(address(this), msg.sender, tokenId);
    
    emit CollateralWithdrawn(msg.sender, tokenId);
}
```

3. Functions that handle partial operations without proper cleanup

This often appears in functions that can exit early or complete partially. Consider this problematic example:
```solidity
// Dangerous: Partial operation leaves state unclear
function batchProcessCollateral(uint256[] calldata tokenIds) external {
    for (uint256 i = 0; i < tokenIds.length; i++) {
        if (!isValidToken(tokenIds[i])) {
            return; // Early exit without cleanup!
        }
        processToken(tokenIds[i]);
    }
}
```

A better approach tracks what was processed and ensures cleanup:
```solidity
function batchProcessCollateral(uint256[] calldata tokenIds) external {
    uint256 processedCount = 0;
    
    for (uint256 i = 0; i < tokenIds.length; i++) {
        if (!isValidToken(tokenIds[i])) {
            break;
        }
        processToken(tokenIds[i]);
        processedCount++;
    }
    
    // Cleanup partial processing
    if (processedCount > 0) {
        updateProcessingState(processedCount);
    }
    
    emit BatchProcessingComplete(processedCount, tokenIds.length);
}
```

4. Discrepancies between accounting systems

This occurs when a protocol maintains multiple records of the same information that can become out of sync. For example:
```solidity
// Dangerous: Multiple sources of truth
contract RiskyPool {
    mapping(address => uint256) public userBalances;      // Direct balance tracking
    mapping(address => uint256) public poolShares;        // Share-based tracking
    uint256 public totalPoolBalance;                      // Total pool balance
    
    function deposit(uint256 amount) external {
        userBalances[msg.sender] += amount;
        // Missing: poolShares update
        totalPoolBalance += amount;
        // Now userBalances and poolShares are out of sync!
    }
}
```

A better approach would be:
```solidity
contract SafePool {
    mapping(address => uint256) public poolShares;        // Single source of truth
    uint256 public totalPoolShares;
    uint256 public totalPoolBalance;
    
    function deposit(uint256 amount) external {
        uint256 sharesToMint = calculateShares(amount);
        poolShares[msg.sender] += sharesToMint;
        totalPoolShares += sharesToMint;
        totalPoolBalance += amount;
        
        require(validatePoolState(), "Pool state inconsistent");
        emit Deposit(msg.sender, amount, sharesToMint);
    }
    
    // Helper to ensure state consistency
    function validatePoolState() internal view returns (bool) {
        return totalPoolBalance * totalPoolShares > 0 || 
               totalPoolBalance == 0 && totalPoolShares == 0;
    }
}
```

When auditing, actively look for these patterns by:
1. Tracing all possible execution paths through state-changing functions
2. Creating diagrams of state transitions and asset flows
3. Testing edge cases and partial completions
4. Verifying that all related state variables remain consistent
5. Checking that cleanup operations happen in all scenarios, not just the happy path
### Tools
### Refine

- [[1-Business_Logic]]
- [[12-Do_not_Update_state]]

---
## [M-12] Deposits are eliminated before currently unclaimed reserves when there is no reserve auction
----
- **Tags**: #business_logic #auction 
- Number of finders: 1
- Difficulty: Hard
---
### Summary

Reserves that were unclaimed during last reserve auction that's now ended are not utilized for bad debt coverage and are treated as liabilities despite it is the free reserve funds of the pool.

Due to that deposits are being written off when there are still reserve funds exist and deposits' turn as a last resort liquidity source aren't came yet.

### Vulnerability Detail

Suppose auctioned reserves weren't taken for any reason: say no market participants were there for that particular pool in the period when reserve auction implied Ajna token price was above market. Then there is no liability, i.e. that amount is free pool funds and to be used ahead of HPB deposits to cover any deficits.

Currently that's not happening, instead unclaimed reserves are frozen and aren't used. I.e. system treats these funds as being liable (while they aren't, auction is ended), so only very last reserve funds, that weren't yet added to the reserve auctions pot, can be used to cover bad debt. When there are not enough such funds, deposits are written off.

### Impact

Deposit holders take a loss when the pool in fact do have reserve funds to cover bad debt. This loss isn't a part of the declared mechanics of the protocol.

Reserve auction can end up with not all auctioned reserves taken frequently enough due to, for example:

- short period of time when Ajna token were overpriced in it,
    
- or this period intersecting with spike of gas prices that made it unprofitable in absolute terms,
    
- or low liquidity of Ajna token at that time.
    

I.e. the reason can vary, the point is reserve auction not being sold out can be a regular outcome, while the expected sequence of funds to cover bad debt is typical and is stated in whitepaper (part 7.6, Settling, point 3 in the list), so it will be expected by the lenders that the reserves are covering bad debt first.

### Code Snippet

`settlePoolDebt()` uses the reserves to cover bad debt:

[external/Auctions.sol#L277-L313](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L277-L313)
```solidity
        // if there's still debt and no collateral
        if (borrower.t0Debt != 0 && borrower.collateral == 0) {
            // settle debt from reserves -- round reserves down however
            borrower.t0Debt -= Maths.min(borrower.t0Debt, (params_.reserves / params_.inflator) * 1e18);

            // if there's still debt after settling from reserves then start to forgive amount from next HPB
            // loop through remaining buckets if there's still debt to settle
            while (params_.bucketDepth != 0 && borrower.t0Debt != 0) {
                SettleLocalVars memory vars;

                (vars.index, , vars.scale) = Deposits.findIndexAndSumOfSum(deposits_, 1);
                vars.unscaledDeposit = Deposits.unscaledValueAt(deposits_, vars.index);
                vars.depositToRemove = Maths.wmul(vars.scale, vars.unscaledDeposit);
                vars.debt            = Maths.wmul(borrower.t0Debt, params_.inflator);

                // enough deposit in bucket to settle entire debt
                if (vars.depositToRemove >= vars.debt) {
                    Deposits.unscaledRemove(deposits_, vars.index, Maths.wdiv(vars.debt, vars.scale));
                    borrower.t0Debt  = 0;                                                              // no remaining debt to settle

                // not enough deposit to settle entire debt, we settle only deposit amount
                } else {
                    borrower.t0Debt -= Maths.wdiv(vars.depositToRemove, params_.inflator);             // subtract from remaining debt the corresponding t0 amount of deposit

                    Deposits.unscaledRemove(deposits_, vars.index, vars.unscaledDeposit);              // Remove all deposit from bucket
                    Bucket storage hpbBucket = buckets_[vars.index];
                    
                    if (hpbBucket.collateral == 0) {                                                   // existing LPB and LP tokens for the bucket shall become unclaimable.
                        emit BucketBankruptcy(vars.index, hpbBucket.lps);
                        hpbBucket.lps            = 0;
                        hpbBucket.bankruptcyTime = block.timestamp;
                    }
                }

                --params_.bucketDepth;
            }
        }
```

But this reserves do not include `reserveAuction.unclaimed`, which is treated like a liability even when there is no reserve auction:

[ERC721Pool.sol#L353-L365](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L353-L365)

```solidity
    function settle(
        address borrowerAddress_,
        uint256 maxDepth_
    ) external nonReentrant override {
        PoolState memory poolState = _accruePoolInterest();

        uint256 assets = Maths.wmul(poolBalances.t0Debt, poolState.inflator) + _getPoolQuoteTokenBalance();
        uint256 liabilities = Deposits.treeSum(deposits) + auctions.totalBondEscrowed + reserveAuction.unclaimed;

        SettleParams memory params = SettleParams(
            {
                borrower:    borrowerAddress_,
                reserves:    (assets > liabilities) ? (assets-liabilities) : 0,
```

[ERC20Pool.sol#L356-L378](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC20Pool.sol#L356-L378)

```solidity
    function settle(
        address borrowerAddress_,
        uint256 maxDepth_
    ) external override nonReentrant {
        PoolState memory poolState = _accruePoolInterest();

        uint256 assets = Maths.wmul(poolBalances.t0Debt, poolState.inflator) + _getPoolQuoteTokenBalance();

        uint256 liabilities = Deposits.treeSum(deposits) + auctions.totalBondEscrowed + reserveAuction.unclaimed;

        (
            ,
            ,
            uint256 collateralSettled,
            uint256 t0DebtSettled
        ) = Auctions.settlePoolDebt(
            auctions,
            buckets,
            deposits,
            loans,
            SettleParams({
                borrower:    borrowerAddress_,
                reserves:    (assets > liabilities) ? (assets - liabilities) : 0,
```

Reserve auction finishes by timer and there is no adjustments to `unclaimed` if it is not sold fully:

[Auctions.sol#L642-L663](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L642-L663)

```solidity
    function takeReserves(
        ReserveAuctionState storage reserveAuction_,
        uint256 maxAmount_
    ) external returns (uint256 amount_, uint256 ajnaRequired_) {
        uint256 kicked = reserveAuction_.kicked;

        if (kicked != 0 && block.timestamp - kicked <= 72 hours) {
            uint256 unclaimed = reserveAuction_.unclaimed;
            uint256 price     = _reserveAuctionPrice(kicked);

            amount_       = Maths.min(unclaimed, maxAmount_);
            ajnaRequired_ = Maths.wmul(amount_, price);

            unclaimed -= amount_;

            reserveAuction_.unclaimed = unclaimed;

            emit ReserveAuction(unclaimed, price);
        } else {
            revert NoReservesAuction();
        }
    }
```
### Recommended Mitigation

Consider removing currently unsettled `reserveAuction.unclaimed` if reserve auction doesn't take place now as those aren't liabilities:

[ERC721Pool.sol#L353-L382](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L353-L382)

```solidity
    function settle(
        address borrowerAddress_,
        uint256 maxDepth_
    ) external nonReentrant override {
        PoolState memory poolState = _accruePoolInterest();
+       uint256 kicked = reserveAuction.kicked;     
+       uint256 reservesAuctioned = (kicked != 0 && block.timestamp - kicked <= 72 hours) ? reserveAuction.unclaimed : 0;   

        uint256 assets = Maths.wmul(poolBalances.t0Debt, poolState.inflator) + _getPoolQuoteTokenBalance();
-       uint256 liabilities = Deposits.treeSum(deposits) + auctions.totalBondEscrowed + reserveAuction.unclaimed;
+       uint256 liabilities = Deposits.treeSum(deposits) + auctions.totalBondEscrowed + reservesAuctioned;

        SettleParams memory params = SettleParams(
            {
                borrower:    borrowerAddress_,
                reserves:    (assets > liabilities) ? (assets-liabilities) : 0,
                inflator:    poolState.inflator,
                bucketDepth: maxDepth_,
                poolType:    poolState.poolType
            }
        );
        (
            uint256 collateralRemaining,
            uint256 t0DebtRemaining,
            uint256 collateralSettled,
            uint256 t0DebtSettled
        ) = Auctions.settlePoolDebt(
            auctions,
            buckets,
            deposits,
            loans,
+           reserveAuction,
            params
        );
```

[ERC20Pool.sol#L356-L378](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC20Pool.sol#L356-L378)

```solidity
    function settle(
        address borrowerAddress_,
        uint256 maxDepth_
    ) external override nonReentrant {
        PoolState memory poolState = _accruePoolInterest();
+       uint256 kicked = reserveAuction.kicked;        
+       uint256 reservesAuctioned = (kicked != 0 && block.timestamp - kicked <= 72 hours) ? reserveAuction.unclaimed : 0;

        uint256 assets = Maths.wmul(poolBalances.t0Debt, poolState.inflator) + _getPoolQuoteTokenBalance();

-       uint256 liabilities = Deposits.treeSum(deposits) + auctions.totalBondEscrowed + reserveAuction.unclaimed;
+       uint256 liabilities = Deposits.treeSum(deposits) + auctions.totalBondEscrowed + reservesAuctioned;

        (
            ,
            ,
            uint256 collateralSettled,
            uint256 t0DebtSettled
        ) = Auctions.settlePoolDebt(
            auctions,
            buckets,
            deposits,
            loans,
+           reserveAuction,
            SettleParams({
                borrower:    borrowerAddress_,
                reserves:    (assets > liabilities) ? (assets - liabilities) : 0,
```

Reserve auction state can be added as an argument to provide these fields:

[Auctions.sol#L199-L205](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L199-L205)

```solidity
    function settlePoolDebt(
        AuctionsState storage auctions_,
        mapping(uint256 => Bucket) storage buckets_,
        DepositsState storage deposits_,
        LoansState storage loans_,
+       ReserveAuctionState storage reserveAuction_,
        SettleParams memory params_
    ) external returns (
```

Also, consider accounting for the reserves that were used to cover bad debt (otherwise next reserve auction will be frozen until new income replenishes the funds used for coverage):

[Auctions.sol#L277-L283](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L277-L283)

```solidity
        // if there's still debt and no collateral
        if (borrower.t0Debt != 0 && borrower.collateral == 0) {
            // settle debt from reserves -- round reserves down however
+           uint256 reservesUsed = Maths.min(borrower.t0Debt, (params_.reserves / params_.inflator) * 1e18);
+           uint256 kicked       = reserveAuction_.kicked;
-           borrower.t0Debt -= Maths.min(borrower.t0Debt, (params_.reserves / params_.inflator) * 1e18);
+           borrower.t0Debt -= reservesUsed;
+           if (kicked != 0 && block.timestamp - kicked <= 72 hours) reserveAuction_.unclaimed -= reservesUsed;

            // if there's still debt after settling from reserves then start to forgive amount from next HPB
            // loop through remaining buckets if there's still debt to settle
```
### Discussion

**grandizzy:**

unclaimed auction reserves won't be available to fund a liquidation, this is an issue which we are going to document, no code change involved

**hrishibhat:**

Classifying this issue as a medium based on the above comment.

### Notes & Impressions

#### Notes 
Let me walk you through a concrete example to illustrate this issue.

Let's say we have a lending pool with these initial conditions:
- Total deposits from lenders: 1000 USDC
- Total reserves accumulated: 200 USDC
- A borrower has a loan of 500 USDC backed by some NFT collateral

Now let's see how a sequence of events reveals the problem:

1. First, a reserve auction is initiated:
```
Initial reserves: 200 USDC
Amount put up for auction: 200 USDC
```

2. During the 72-hour auction window, only half the reserves are claimed:
```
Claimed reserves: 100 USDC (somebody bought these with AJNA tokens)
Unclaimed reserves: 100 USDC (nobody bought these)
```

3. The auction ends, but that 100 USDC of unclaimed reserves is still marked as "locked" even though the auction is over.

4. Now the borrower defaults on their 500 USDC loan, and their NFT collateral only sells for 300 USDC. This leaves 200 USDC of bad debt that needs to be covered.

5. The protocol tries to cover this bad debt:
```
Assets = 300 USDC (from NFT sale)
Liabilities = 1000 USDC (deposits) + 100 USDC (unclaimed reserves incorrectly counted as liability)
Available reserves = Assets - Liabilities = 0 USDC
```

6. Because the protocol wrongly thinks it has no reserves available (when it actually has that unclaimed 100 USDC), it starts writing off depositor funds:
```
Bad debt to cover: 200 USDC
Reserves used: 0 USDC
Depositor funds written off: 200 USDC
```

What should have happened:
```
Assets = 300 USDC (from NFT sale) + 100 USDC (unclaimed reserves properly recognized)
Liabilities = 1000 USDC (deposits only)
Available reserves = 100 USDC

Bad debt to cover: 200 USDC
Reserves used: 100 USDC
Depositor funds written off: 100 USDC
```

In this corrected scenario, depositors would only lose 100 USDC instead of 200 USDC, because the unclaimed reserves would be properly used first. This aligns with the protocol's intended design where reserves act as the first line of defense against bad debt, protecting depositor funds as much as possible.

This example shows how the current implementation can lead to unnecessary losses for depositors, simply because the code doesn't properly recognize when auction-locked reserves should become available again. The impact multiplies in larger pools or when multiple reserve auctions don't fully clear.

#### Impressions

- pay attention to edge cases (unclaimed)

### Tools
### Refine

- [[1-Business_Logic]]

---
## [M-16] Auction timers following liquidity can fall through the floor price causing pool insolvency
----
- **Tags**: #lending_pool #business_logic #auction
- Number of finders: 1
- Difficulty: Medium
---
### Summary

When a borrower cannot pay their debt in an ERC20 pool, their position is liquidated and their assets enter an auction for other users to purchase small pieces of their assets. Because of the incentive that users wish to not pay above the standard market price for a token, users will generally wait until assets on auction are as cheap as possible to purchase however, this is flawed because this guarantees a loss for all lenders participating in the protocol with each user that is liquidated.

### Detail

Consider a situation where a user decides to short a coin through a loan and refuses to take the loss to retain the value of their position. When the auction is kicked off using the `kick()` function on this user, as time moves forward, the price for puchasing these assets becomes increasingly cheaper. These prices can fall through the floor price of the lending pool which will allow anybody to buy tokens for only a fraction of what they were worth originally leading to a state where the pool cant cover the debt of the user who has not paid their loan back with interest. The issue lies in the `_auctionPrice()` function of the `Auctions.sol` contract which calculates the price of the auctioned assets for the taker. 

[Auctions.sol#L1390-L1411](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L1390-L1411)
```solidity
    /**
     *  @notice Calculates auction price.
     *  @param  kickMomp_     MOMP recorded at the time of kick.
     *  @param  neutralPrice_ Neutral Price of the auction.
     *  @param  kickTime_     Time when auction was kicked.
     *  @return price_        Calculated auction price.
     */
    function _auctionPrice(
        uint256 kickMomp_,
        uint256 neutralPrice_,
        uint256 kickTime_
    ) internal view returns (uint256 price_) {
        uint256 elapsedHours = Maths.wdiv((block.timestamp - kickTime_) * 1e18, 1 hours * 1e18);


        elapsedHours -= Maths.min(elapsedHours, 1e18);  // price locked during cure period


        int256 timeAdjustment  = PRBMathSD59x18.mul(-1 * 1e18, int256(elapsedHours)); 
        uint256 referencePrice = Maths.max(kickMomp_, neutralPrice_); 


        price_ = 32 * Maths.wmul(referencePrice, uint256(PRBMathSD59x18.exp2(timeAdjustment)));
    }


```

This function does not consider the floor price of the pool. The proof of concept below outlines this scenario:

```solidity
    function testInsolvency() public {
        
        // ============== Setup Scenario ==============
        uint256 interestRateOne = 0.05 * 10**18;           // Collateral  // Quote (loaned token, short position)
        address poolThreeAddr = erc20PoolFactory.deployPool(address(dai), address(weth), interestRateOne);
        ERC20Pool poolThree = ERC20Pool(address(poolThreeAddr));
        vm.label(poolThreeAddr, "DAI / WETH Pool Three");

        // Setup scenario and send liquidity providers some tokens
        vm.startPrank(address(daiDoner));
        dai.transfer(address(charlie), 3200 ether);
        vm.stopPrank();

        vm.startPrank(address(wethDoner));
        weth.transfer(address(bob), 1000 ether);
        vm.stopPrank();

        // ==============================================


        // Note At the time (24/01/2023) of writing ETH is currently 1,625.02 DAI,
        // so this would be a popular bucket to deposit in.

        // Start Scenario
        // The lower dowm we go the cheaper wETH becomes - At a concentrated fenwick index of 5635, 1 wETH = 1600 DAI (Approx real life price)
        uint256 fenwick = 5635; // This index represents price where 1 WETH = 1600 DAI

        vm.startPrank(address(alice));
        weth.deposit{value: 2 ether}();
        weth.approve(address(poolThree), 2.226 ether);
        poolThree.addQuoteToken(2 ether, fenwick); 
        vm.stopPrank();

        vm.startPrank(address(bob));
        weth.deposit{value: 9 ether}();
        weth.approve(address(poolThree), 9 ether);
        poolThree.addQuoteToken(9 ether, fenwick); 
        vm.stopPrank();

        assertEq(weth.balanceOf(address(poolThree)), 11 ether);


        // ======================== start testing ========================

        vm.startPrank(address(bob));
        bytes32 poolSubsetHashes = keccak256("ERC20_NON_SUBSET_HASH");
        IPositionManagerOwnerActions.MintParams memory mp = IPositionManagerOwnerActions.MintParams({
            recipient: address(bob),
            pool: address(poolThree),
            poolSubsetHash: poolSubsetHashes
        });
        positionManager.mint(mp);
        positionManager.setApprovalForAll(address(rewardsManager), true);
        rewardsManager.stake(1);
        vm.stopPrank();


        assertEq(dai.balanceOf(address(charlie)), 3200 ether);
        vm.startPrank(address(charlie)); // Charlie runs away with the weth tokens
        dai.approve(address(poolThree), 3200 ether);
        poolThree.drawDebt(address(charlie), 2 ether, fenwick, 3200 ether);
        vm.stopPrank();

        vm.warp(block.timestamp + 62 days); // Time passes


        vm.startPrank(address(bob));
        weth.deposit{value: 0.5 ether}();
        weth.approve(address(poolThree), 0.5 ether);
        poolThree.kick(address(charlie)); // Kick off liquidation
        vm.stopPrank();

        vm.warp(block.timestamp + 10 hours); // More time passes

        assertEq(weth.balanceOf(address(poolThree)), 9020189981190878108); // 9 ether


        vm.startPrank(address(bob));
        // Bob Takes a (pretend) flashloan of 1000 weth to get cheap dai tokens
        // Bob uses a large amount of WETH to take advantage of the low prices
        weth.approve(address(poolThree), 1000 ether);
        poolThree.take(address(charlie), 1000 ether , address(bob), "");
        // Multiple takes to acquire the assets at very low prices
        weth.approve(address(poolThree), 1000 ether);
        poolThree.take(address(charlie), 1000 ether , address(bob), "");
        weth.approve(address(poolThree), 1000 ether);
        poolThree.take(address(charlie), 1000 ether , address(bob), "");
        weth.approve(address(poolThree), 1000 ether);
        poolThree.take(address(charlie), 1000 ether, address(bob), "");
        
        poolThree.settle(address(charlie), 100);
        vm.stopPrank();


        assertEq(weth.balanceOf(address(poolThree)), 9152686732755985308); // Pool balance is still 9 ether instead of 11 ether - insolvency. 
        assertEq(dai.balanceOf(address(bob)), 3200 ether); // The original amount that charlie posted as deposit


        vm.warp(block.timestamp + 2 hours);
        // users attempt to withdraw after shaken by a liquidation
        vm.startPrank(address(alice));
        poolThree.removeQuoteToken(2 ether, fenwick);
        vm.stopPrank();

        vm.startPrank(address(bob));
        poolThree.removeQuoteToken(9 ether, fenwick);
        vm.stopPrank();

        assertEq(weth.balanceOf(address(bob)), 1007664981389220443074); // 1007 ether, originally 1009 ether
        assertEq(weth.balanceOf(address(alice)), 1626148471550317418); // 1.6 ether, originally 2 ether

    }
```
### Impact

An increase in borrowers who cant pay their debts back will result in a loss for all lenders.
### Recommended Mitigation

It's recommended that the price of the assets on auction consider the fenwick(s) being used when determining the price of assets on loan and do not fall below that particular index. With this fix in place, the worst case scenario is that lenders can pruchase these assets for the price they were loaned out for allowing them to recover the loss.

### Discussion

**grandizzy**

this is a design choice. however we're reconsidering the auction implementation to use a floor price

**hrishibhat**

Considering this issue a valid medium as there is a possible risk of funds lost for lenders under certain circumstances

### Notes & Impressions

The lack of a minimum price floor in the liquidation auction mechanism

1. Current Design:

- Auction prices decrease exponentially with time
- No lower bound on how low prices can go
- Allows purchasers to buy collateral far below market value

### Tools
### Refine

- [[1-Business_Logic]]

---
## [M-22] Memorializing an NFT position on the same bucket of a previously memorialized NFT locks redemption
----
- **Tags**: #mapping #business_logic 
- Number of finders: 1
- Difficulty: Hard
---
### Summary

Memorializing a position as an NFT on the same bucket of an existing memorialized position will not allow any of the owners to directly redeem it back later.

### Vulnerability Detail

This issue happens because, after a position is memorialized on the `PositionManager`, this contract will centralize LP positions from different users, but these will be mapped to the same address from the point of view of Ajna pools (different users will be mapped as the same `lender` from the point of view of a `Pool`).

If more than one user has memorialized a position to the same bucket index, when attempting to `PositionManager.redeemPositions`, the call to `pool.transferLPs` will revert with `NoAllowance`, as `LenderActions` does not allow a transfer with value lower than the total `lenderLpBalance`.

[pool.transferLPs](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/PositionManager.sol#L311)
```solidity
    function reedemPositions(
        RedeemPositionsParams calldata params_
    ) external override mayInteract(params_.pool, params_.tokenId) {
    ... ...
        // update pool lp token accounting and transfer ownership of lp tokens from PositionManager contract
        pool.transferLPs(address(this), owner, params_.indexes);
    }
```

[NoAllowance](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/LenderActions.sol#L538)
```solidity
    function transferLPs(
        mapping(uint256 => Bucket) storage buckets_,
        mapping(address => mapping(address => mapping(uint256 => uint256))) storage allowances_,
        address owner_,
        address newOwner_,
        uint256[] calldata indexes_
    ) external {
... ...

            if (transferAmount == 0 || transferAmount != lenderLpBalance) revert NoAllowance();

... ...
}
```

Because of that, any of the users' that share a bucket `redeemPositions` calls will fail.

### Impact

Although users that share a bucket with memorialized positions are not able to direct redeem their positions, they can eventually get their LPs back with a specific set of actions.

By first calling `PositionManager.moveLiquidity` to a bucket _without any other LPs_ managed by `PositionsManager` (since `LenderActions.moveQuoteToken` accepts moving less liquidity than the total a LP balance for a specific bucket), and then calling `PositionManager.redeemPositions`, LP-ers will be able to redeem their positions back. Because of this possibility, this is a Medium-severity issue.

```solidity
diff --git a/contracts/tests/forge/PositionManager.t.sol b/contracts/tests/forge/PositionManager.t.sol
index 5e691fc..5d5e822 100644
--- a/contracts/tests/forge/PositionManager.t.sol
+++ b/contracts/tests/forge/PositionManager.t.sol
@@ -186,6 +186,91 @@ contract PositionManagerERC20PoolTest is PositionManagerERC20PoolHelperContract
         assertTrue(_positionManager.isIndexInPosition(tokenId, 2552));
     }
 
+    function testMemorializePositionsTwoAccountsSameBucket() external {
+        address alice = makeAddr("alice");
+        address bob = makeAddr("bob");
+        uint256 mintAmount  = 10_000 * 1e18;
+
+        uint256 lpBalance;
+        uint256 depositTime;
+
+        _mintQuoteAndApproveManagerTokens(alice, mintAmount);
+        _mintQuoteAndApproveManagerTokens(bob, mintAmount);
+
+        // call pool contract directly to add quote tokens
+        uint256[] memory indexes = new uint256[](1);
+        indexes[0] = 2550;
+
+        // alice adds liquidity now
+        _addInitialLiquidity(
+            {
+                from:   alice,
+                amount: 3_000 * 1e18,
+                index:  indexes[0]
+            }
+        );
+        (lpBalance, depositTime) = _pool.lenderInfo(indexes[0], alice);
+        uint256 aliceDepositTime = block.timestamp;
+        assertEq(lpBalance, 3_000 * 1e27);
+        assertEq(depositTime, aliceDepositTime);
+
+        // bob adds liquidity later
+        skip(1 hours);
+        _addInitialLiquidity(
+            {
+                from:   bob,
+                amount: 3_000 * 1e18,
+                index:  indexes[0]
+            }
+        );
+        (lpBalance, depositTime) = _pool.lenderInfo(indexes[0], bob);
+        assertEq(lpBalance, 3_000 * 1e27);
+        assertEq(depositTime, aliceDepositTime + 1 hours);
+
+
+        // bob memorializes first, alice memorializes second
+        address[] memory addresses = new address[](2);
+        addresses[0] = bob;
+        addresses[1] = alice;
+        uint256[] memory tokenIds = new uint256[](2);
+
+        // bob and alice mint an NFT to later memorialize existing positions into
+        tokenIds[0] = _mintNFT(bob, bob, address(_pool));
+        assertFalse(_positionManager.isIndexInPosition(tokenIds[0], 2550));
+        tokenIds[1] = _mintNFT(alice, alice, address(_pool));
+        assertFalse(_positionManager.isIndexInPosition(tokenIds[1], 2550));
+
+        for(uint256 i = 0; i < addresses.length; ++i) {
+            // construct memorialize params struct
+            IPositionManagerOwnerActions.MemorializePositionsParams memory memorializeParams = IPositionManagerOwnerActions.MemorializePositionsParams(
+                tokenIds[i], indexes
+            );
+
+            // allow position manager to take ownership of the position
+            changePrank(addresses[i]);
+            _pool.approveLpOwnership(address(_positionManager), indexes[0], 3_000 * 1e27);
+
+            // memorialize quote tokens into minted NFT
+            vm.expectEmit(true, true, true, true);
+            emit MemorializePosition(addresses[i], tokenIds[i]);
+            vm.expectEmit(true, true, true, true);
+            emit TransferLPTokens(addresses[i], address(_positionManager), indexes, 3_000 * 1e27);
+
+            _positionManager.memorializePositions(memorializeParams);
+        }
+
+        // now both redeem
+        // will revert
+        for(uint256 i = 0; i < addresses.length; ++i) {
+            // construct memorialize params struct
+            IPositionManagerOwnerActions.RedeemPositionsParams memory params = IPositionManagerOwnerActions.RedeemPositionsParams(
+                tokenIds[i], address(_pool), indexes
+            );
+            changePrank(addresses[i]);
+            _positionManager.reedemPositions(params);
+        }
+    }
+
     function testRememorializePositions() external {
         address testAddress = makeAddr("testAddress");
         uint256 mintAmount  = 50_000 * 1e18;

```

### Recommendation

There are some possible alternatives to solving this issue.

1. Allow `LenderActions.transferLPs` to transfer an amount different than the total LP balance. Appropriate care must be taken with [approve/transfer](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#) [attack vectors](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#), that do not exist now as approvals are always exact and cleared after every transfer, but they may become important if the this flow is refactored.
    
2. Reconsider the `PositionsManager` architecture and the way the LP balances are stored on the Ajna protocol. Since positions are not tokenized by default, but instead are stored on state variables on each pool, it is arguably more complex to reason about transferring positions between two users. Conversely, the ERC-20 and ERC-721 standards already provide straightforward methods for minting/burning/sending tokens for accounts. A suggestion is, for example, to remove the optionality of NFT minting through another independent contract (the `PositionManager.sol`), and instead to refactor the Ajna pools so that every position is an ERC-721 NFT minted directly by the `Pool.sol`.
### Discussion

### Notes & Impressions

Real-World Analogy: Think of a bank where you can deposit money into different types of savings accounts (these are like the "buckets" in the protocol). The bank offers a special service where you can convert your savings account into a commemorative coin (like the NFT). The catch is that the bank has a rule that you can only withdraw the entire amount in an account at once.

Now let's look at what happens in the smart contract with actual examples:

Example Scenario 1 - The Normal Case:

```
// Alice deposits 3000 tokens into bucket #2550
Alice -> Bucket #2550: 3000 tokens
// Alice memorializes this into NFT #1
Alice's NFT #1 represents: 3000 tokens in bucket #2550
// Alice can successfully redeem later
Alice redeems NFT #1 -> Gets back 3000 tokens
```


Example Scenario 2 - The Problem Case:

```
// First, Alice deposits
Alice -> Bucket #2550: 3000 tokens
// Then Bob also deposits in the same bucket
Bob -> Bucket #2550: 3000 tokens

// Now they both memorialize their positions
Alice's NFT #1 represents: 3000 tokens in bucket #2550
Bob's NFT #2 represents: 3000 tokens in bucket #2550

// Problem occurs when trying to redeem:
Alice tries to redeem NFT #1 -> FAILS!
Bob tries to redeem NFT #2 -> FAILS!
```

Why does it fail? Because from the pool's perspective, the PositionManager now looks like this:

```
Bucket #2550:
  Total Balance: 6000 tokens
  Owner: PositionManager
```

When Alice tries to withdraw 3000 tokens, the contract says "Sorry, you must withdraw all 6000 tokens or nothing at all!" But Alice's NFT only gives her the right to 3000 tokens, not all 6000.

#### Impressions

Error Type: Part Vs Whole
### Tools
### Refine

- [[1-Business_Logic]]

---

## Audit Summary Notes
- {{summary_notes}}

## Tags
- Category: {{tags_category}}
- Priority:{{tags_priority}}