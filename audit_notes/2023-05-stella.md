# 2023-05-Stella
---
- Category: #Lending #UniswapV3 
- Note Create 2024-12-21
- Platform: Trust Security
- Report Url: [2023-05-29-Stella](https://github.com/solodit/solodit_content/blob/main/reports/Trust%20Security/2023-05-29-Stella.md)
---
# High Risk Findings (xx)

---
## [H-01] Incorrect implementation of `getProfitSharingE18()` greatly reduces Lender's yield
----
- **Tags**:  #wrong_math #business_logic 
- Number of finders: nnn
- Difficulty: Medium
---
### Description:

`ProfitSharingModel.getProfitSharingE18()` calculates the share of profit that Lender gets based on the APR of the position. According to the formula, the higher the APR, the lower the share of profit the Lender gets, but due to the wrong implementation of the `getProfitSharingE18()` function, if the APR is smaller than **MAX_ANNUALIZED_YEILD**, the base share of 25% is returned, actually 25% should be returned when the APR is larger than **MAX_ANNUALIZED_YEILD**.  

Considering an APR of 5%, Lender's share of the profit should be 77%, while  
getProfitSharingE18() returns 25%, which greatly reduces Lender's share of the profit.
### Recommended Mitigation

Modify `getProfitSharingE18()` as follows

```solidity
            - if (_annualizedYieldE18 < MAX_ANNUALIZED_YEILD) {
            + if (_annualizedYieldE18 >= MAX_ANNUALIZED_YEILD) { 
            return 0.25e18;
            }
```

### Discussion


### Notes

#### Notes 
The intended design principle here is:

- When APR is low: Lenders should get a larger share of profits (to incentivize lending)
- When APR is high: Lenders should get a smaller share (as they're already earning well from interest)
#### Impressions


### Tools
### Refine

- [[1-Business_Logic]]

---
## [H-07] Pending position fees miscalculation may result in increased PnL

----
- **Tags**:  #wrong_math #business_logic 
- Number of finders: 1
- Difficulty: Medium
---
### Description:

When calculating pending liquidity position fees, **liquidity, tokensOwed0, and tokensOwed1**  are read from a Uniswap V3 pool using a position belonging to the  `NonfungiblePositionManager` contract. 

However, the read values will also include the liquidity and the owed token amounts of all Uniswap V3 users who deposited funds in the price range of the position via the `NonfungiblePositionManager` contract. 

Since  `NonfungiblePositionManager` manages positions in pools on behalf of users, the positions will  hold liquidity of all `NonfungiblePositionManager` users. 

As a result, the PnL of  `UniswapV3Strategy` positions may be significantly increased, resulting in increased payouts to lenders and loss of funds to `borrowers/liquidators`.

### Proof of Concept

### Recommended Mitigation

Consider reading the values of liquidity, **tokensOwed0, and tokensOwed1** from the  
`IUniswapV3NPM(uniV3NPM).positions()` call on line 95. The call returns values specifically for  
the position identified by the token ID.

### Discussion


### Notes

#### Notes 
- `IUniswapV3NPM(uniV3NPM).positions(tokenId)`
#### Impressions

Imagine a large apartment building (the Uniswap V3 pool) where multiple tenants (liquidity providers) can rent apartments (provide liquidity) on the same floor (price range). The NPM is like a property management company that handles multiple apartments. If you ask the building directly about utilities used on floor 5, you'll get the total for all apartments on that floor. However, if you ask the property management company about a specific apartment's utilities, you'll get the correct individual reading.

### Tools
### Refine

- [[1-Business_Logic]]

---
## [H-08] “Exact output” swaps cannot be executed, blocking repayment of debt
----
- **Tags**:  #slippage #business_logic 
- Number of finders: nnn
- Difficulty: Medium
---
### Description:

When performing “exact output” swaps via Uniswap V2 and V3, the maximum input amount argument (**amountInMax** when calling Uniswap V2’s `swapTokensForExactTokens()`, **amountInMaximum** when calling V3’s `exactOutput()`) is set to 0. As a result, swapping attempts will always revert because no more than 0 input tokens can be sold (the slippage check in the Uniswap contracts will always revert because the swaps will require more input tokens).

We consider it high-severity because an “exact output” swap is mandatory when closing a  
position that doesn’t have enough tokens to repay([https://github.com/AlphaFinanceLab/stella-arbitrum-private-contract/blob/3a4e99307e9cbf790279e49a4d90771e5486c51d/contracts/stella-strategies/strategies/base/BaseStrategy.sol#L224](https://github.com/AlphaFinanceLab/stella-arbitrum-private-contract/blob/3a4e99307e9cbf790279e49a4d90771e5486c51d/contracts/stella-strategies/strategies/base/BaseStrategy.sol#L224)) the borrowed amount. Thus, since “exact  
output” swaps are not possible, closing some positions won’t be possible as well, leaving funds  
locked in the contract.

### Recommended Mitigation

Taking into account that the protocol implements delayed slippage checks, consider setting the maximum input amount arguments to **type(uint256).max.**

```solidity
// Current problematic implementation
function swapExactOutput(
    address tokenIn,
    address tokenOut,
    uint256 amountOut
) internal {
    // This will always fail
    IUniswapRouter.exactOutputSingleParams memory params = 
        IUniswapRouter.exactOutputSingleParams({
            tokenIn: tokenIn,
            tokenOut: tokenOut,
            fee: fee,
            recipient: address(this),
            deadline: block.timestamp,
            amountOut: amountOut,
            amountInMaximum: 0,  // This is the problem!
            sqrtPriceLimitX96: 0
        });
}

// Corrected implementation
function swapExactOutput(
    address tokenIn,
    address tokenOut,
    uint256 amountOut
) internal {
    // This will work as expected
    IUniswapRouter.exactOutputSingleParams memory params = 
        IUniswapRouter.exactOutputSingleParams({
            tokenIn: tokenIn,
            tokenOut: tokenOut,
            fee: fee,
            recipient: address(this),
            deadline: block.timestamp,
            amountOut: amountOut,
            amountInMaximum: type(uint256).max,  // Allow maximum possible input
            sqrtPriceLimitX96: 0
        });
}
```
### Discussion

### Notes

#### Impressions

Imagine you need exactly $100 to pay rent (exact output), and you're willing to exchange foreign currency to get it. Setting amountInMax to 0 is like telling the currency exchange: "I need exactly $100, but I'm not willing to spend any foreign currency to get it." Obviously, this transaction can't succeed.

### Tools
### Refine

- [[1-Business_Logic]]

---

---

# Medium Risk Findings (xx)

---

{{Copy from Medium Risk Finding Template.md}}

---

## Audit Summary Notes
- {{summary_notes}}

## Tags
- Category: {{tags_category}}
- Priority:{{tags_priority}}