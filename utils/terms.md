# Terms in DeFi

## Basic
- refund: 退款
- redeem:
- redemption: 赎回
- ledger: 账簿，分类账，总账
- recipient: 收款人
- payer: 付款人
- stream: 分期付款，流式转账
- EMI ( Equated Monthly Installment): 等额月供
- compound interest: 复利
- linear interest: 单利
- Derivatives: 衍生品

## Deposit

Deposits are like savings accounts in a bank. When lenders (or depositors) put their tokens (like USDC or ETH) into the protocol, they're essentially making deposits. These depositors expect to earn interest on their deposits, just like you earn interest on a savings account. The protocol uses these deposits as a lending pool from which borrowers can take loans. In the code we saw, deposits are tracked in a deposits tree structure and represent the protocol's primary liabilities - money it owes back to depositors.

### Key
- from (own by) lenders (depositors)
- need back to depositors
- the protocol's primary liabilities 

## Reserves

Reserves are like the bank's profit buffer or emergency fund. They come from several sources:
- A portion of the interest paid by borrowers
- Fees collected from various protocol operations
- Any excess funds generated by the protocol The key purpose of reserves is to protect depositors from losses. When something goes wrong (like a borrower defaulting), reserves are used first before touching depositor funds. In the protocol, reserves can also be auctioned off for AJNA tokens through reserve auctions, which is a unique feature compared to traditional banks.

### Reserve auctions
First, let's understand where reserves come from. When borrowers pay interest on their loans, a portion goes to depositors (like earning interest on your savings), and another portion goes into the reserves. Over time, these reserves accumulate value in the form of whatever token the pool uses (like USDC or ETH).

The auction mechanism serves several purposes:

1. Token Value Support: When people want to buy reserves, they have to use AJNA tokens. This creates natural demand for AJNA tokens. For example, if there are 1000 USDC in reserves up for auction, and people want those USDC, they need to buy and use AJNA tokens to participate in the auction.
2. Protocol Sustainability: By requiring AJNA tokens for reserve purchases, the protocol ensures that its native token has real utility and value. This is similar to how Maker requires MKR tokens for governance and fee payments.
3. Price Discovery: The auction format helps find the fair market price for reserves in terms of AJNA tokens. The auction price starts high and decreases over time, letting the market determine the right exchange rate.

### Key
- own by protocol
- less than deposit
- for protocol management
- (option) auction


## Interest (利息)

- **单利（Linear Interest / Simple Interest）**  
    单利只以初始本金作为计算利息的依据，不考虑前期已经产生的利息。也就是说，每个计息期内产生的利息金额固定，与时间长度成正比。例如，若本金为 P，年利率为 r，经过 t 年后，总利息为 P × r × t，最终金额为：
    
    > A = P(1 + r·t)  
    > 每年的收益是固定的，不会因前期利息而增多。
- **复利（Compounded Interest / Compound Interest）**  
    复利不仅以本金计算利息，而且将每期产生的利息累加到本金中，再次计算下一期的利息，即“利滚利”。如果本金为 P，年利率为 r，经过 t 年后，总金额为：
    
    > A = P × (1 + r)^(t)  
    > 当复利的计息周期不是一年时，公式可推广为：  
    > A = P × (1 + r/n)^(n·t)  
    > 其中 n 表示每年复利的次数。这种方式使得利息随着时间呈**指数增长**。

---
### 2. 增长方式和效果

- **增长速度**
    
    - 单利增长是**线性增长**：每个计息期利息相同，增长速度恒定。
    - 复利增长是**指数增长**：由于每期利息均加入本金中，后续计算时本金基数不断增大，因此增长速度越来越快。
- **长期效果**  
    在相同本金、利率和期限下，复利累计的利息明显高于单利。这也是为什么在长期投资或贷款中，复利效应常被视为“时间的魔力”，既能使财富迅速增值，也可能使债务不断累积。
    

---

### 3. 应用场景

- **单利**  
    常用于短期贷款、部分储蓄产品或民间借贷中，因为计算简单、每期收益固定，适合期限较短的金融工具。
    
- **复利**  
    广泛用于长期投资、储蓄账户、定期存款和贷款（例如房贷）的计算。由于复利能带来更高的累计利息，投资者常利用复利效应实现财富增值，而债务人则需要注意复利可能导致负担加重。
    

---
### 4. 小结

- **计算公式**
    
    - 单利：A = P(1 + r·t)
    - 复利：A = P × (1 + r/n)^(n·t) 或 A = P × (1 + r)^(t)（当计息周期为一年时）

当每年利率不同的情况下，复利的计算不再是简单的指数形式 A = P × (1 + r)ⁿ，而是需要把每一年的增长因子连乘起来，即

> A = P × ∏₍ᵢ₌₁₎ⁿ (1 + rᵢ)
    
- **核心差异**  
    单利只计算本金的利息，而复利则是将已得利息与本金一起作为下期计算基础，从而使得总金额随时间呈指数级上升。
    


总体来说，复利在长期运作中能够显著提高资产的增值效应，但同时如果作为债务利息的计算方式，则会使还款压力增大。因此，在不同的金融情境中，理解和选择适当的利息计算方法非常重要。

## Collateral

Collateral is like the property deed you give to a bank when taking a mortgage. When borrowers want to take a loan from the protocol, they must first provide collateral - which could be NFTs in an ERC721 pool or tokens in an ERC20 pool. This collateral serves as security for the loan. If borrowers fail to repay, their collateral can be liquidated (sold) to cover the debt. In the code, collateral is tracked per borrower and can be auctioned off during liquidation events.
### Key
- from borrowers
- own by protocol, when borrowers fail to repay
- need to auction
### Deposits, reserves and collateral in one example

```plaintext
Example Flow:
1. Alice deposits 1000 USDC → becomes part of deposits
2. Bob wants to borrow 700 USDC
3. Bob deposits NFT worth 1000 USDC → becomes collateral
4. Bob borrows 700 USDC from Alice's deposit
5. Bob pays interest → some goes to Alice, some to reserves
6. If Bob defaults:
   - First, sell Bob's NFT collateral
   - If there's still unpaid debt, use reserves
   - Only if reserves are exhausted, use deposits
```


## Dust Attack

The **dust attack** exploits the precision requirements in loan repayments by manipulating the remaining loan balance through tiny ("dust") payments. Here's a step-by-step breakdown:

---

### **How the Dust Attack Works**

1. **Initial State**:
   - A borrower has a loan of **100 ETH** (`loan.amount = 100 ETH`).
   - The borrower intends to repay the full amount before expiry.

2. **Attacker Front-Runs**:
   - The attacker monitors the blockchain for the borrower's repayment transaction.
   - Before the borrower's transaction is processed, the attacker sends a **dust amount** (e.g., **1 wei**, the smallest ETH unit) to `repay()`:
     ```solidity
     repay(loanID, 1 wei); // Reduces loan.amount to 99.999999999999999999 ETH
     ```
   - This reduces `loan.amount` to **99.999... ETH** (100 ETH - 1 wei).

3. **Borrower's Transaction Fails**:
   - The borrower’s transaction attempts to repay the original **100 ETH**:
     ```solidity
     repay(loanID, 100 ETH); // Now, loan.amount is only 99.999... ETH
     ```
   - The contract calculates:
     ```solidity
     loan.amount -= 100 ETH; // Underflows (99.999... ETH - 100 ETH < 0)
     ```
   - The transaction **reverts** due to an underflow error.

4. **Loan Defaults**:
   - If this happens near the loan’s expiry time, the borrower cannot repay in time.
   - The loan defaults, and the lender seizes the collateral (e.g., NFTs, tokens worth more than the loan).

---

### **Why This Matters**
- **Unfair Defaults**: Borrowers lose collateral despite intending to repay.
- **Profit for Attackers**: Attackers may profit by acquiring collateral cheaply post-default.
- **Front-Running Vulnerability**: Miners/attackers can prioritize transactions to exploit timing.

---

### **Solution: Capping Repayments**
Modify the `repay` function to use the **minimum** of `repaid` and `loan.amount`:
```solidity
function repay(uint256 loanID, uint256 repaid) external {
    Loan storage loan = loans[loanID];
    // ...
    uint256 actualRepaid = Math.min(repaid, loan.amount); // Cap repayment
    loan.amount -= actualRepaid; // No underflow
    // ...
}
```
- **Result**: Borrowers can repay **up to** the remaining balance, preventing overpayment failures.

---

### **Key Takeaway**
By capping repayments to the remaining loan balance, the contract becomes resilient to dust attacks, ensuring borrowers can always repay without risking unintended defaults.


## Shortfall

In the context of this smart contract vulnerability, a **shortfall** refers to a **deficit** or **insufficient amount** of funds that occurs when the value of assets required to balance the system exceeds what's available from a swap. Here's a breakdown:

---

### **What is a "Shortfall"?**
1. **Mechanism**:
   - When the `rebalance` function is called, the contract attempts to swap one token (e.g., `assetToken`) for another (e.g., `quoteToken`) to balance the system’s liabilities.
   - The `shortfall` is the **difference** between:
     - The expected amount of `quoteToken` needed (`quoteAmount`), and
     - The actual amount received from the swap (`quoteAmountOut`).

   ```solidity
   int256 shortFall = expectedQuoteAmount - actualQuoteAmountReceived;
   ```

2. **Example**:
   - If the contract expects to receive **100 USDC** from a swap but only gets **80 USDC**, the shortfall is **20 USDC**.
   - This 20 USDC deficit must be covered externally to ensure the system remains solvent.

---

### **How is the Shortfall Exploited?**
1. **Malicious Manipulation**:
   - Attackers intentionally create a large shortfall by manipulating swap parameters (e.g., setting a very low `amountOutMinimum` or unfavorable `sqrtPriceLimitX96`).
   - This forces the swap to return minimal tokens, maximizing the shortfall.

2. **Victim Pays the Shortfall**:
   - The attacker specifies a victim’s address as the `account` parameter.
   - The contract uses `transferFrom` to pull the shortfall amount (e.g., 20 USDC) from the victim’s account, **draining their allowance**.

---

### **Why is This Dangerous?**
- **Arbitrary `account` Parameter**: The `rebalance` function allows anyone to specify which account covers the shortfall.
- **No Validation**: The contract doesn’t check if the `account` is the same as the caller (`msg.sender`), enabling attackers to abuse others’ allowances.

---

### **Key Takeaway**
The shortfall is a **deficit created during rebalancing**, and the vulnerability allows attackers to **force unsuspecting users to pay for it**, draining their approved funds. Fixing this requires ensuring only the transaction caller (`msg.sender`) can be charged for shortfalls.

- [[2023-01-UXD#[H-01] `PerpDespository reblance` and `rebalanceLite` can be called to drain funds from anyone who has approved `PerpDepository`|[H-01] `PerpDespository reblance` and `rebalanceLite` can be called to drain funds from anyone who has approved `PerpDepository`]]


## Delta Neutrality

**Delta-Neutral Explained**  
Delta-neutrality is a risk management strategy used in finance (and crypto) to **eliminate exposure to price movements** of an underlying asset. It’s critical for protocols aiming to maintain stable value (like UDX) while holding volatile collateral (e.g., ETH).

---

### **1. What is "Delta"?**
- **Delta (Δ)** measures how much an asset’s price changes relative to another asset.  
  - Example: If ETH has a delta of 1.0, a $1 ETH price increase raises its value by $1.  
  - For derivatives (e.g., futures), delta represents how much the derivative’s value changes with the underlying asset.

---

### **2. Delta-Neutral Strategy**  
A portfolio is **delta-neutral** if its total delta is **zero**, meaning its value doesn’t change with small price swings.  

#### **How It Works**:
- **Hedge volatile assets with derivatives** (e.g., futures, options).  
- Example:  
  - You hold **$100 ETH** (delta = +1.0).  
  - Short **$100 ETH futures** (delta = -1.0).  
  - Total delta: (+100) + (-100) = **0**.  
  - ETH price changes → Gains in ETH offset losses in futures (and vice versa).  

---

### **3. Delta-Neutrality in UDX**  
UDX aims to be a **stablecoin collateralized 1:1 by assets**, but it uses volatile assets (e.g., ETH) as collateral. To maintain stability:  
1. **Mint UDX**: Users deposit ETH as collateral.  
2. **Hedge ETH Exposure**: Protocol shorts ETH derivatives (e.g., Perpetual futures) to offset ETH price risk.  
   - If ETH price ↓: Loss on ETH collateral is offset by gains on the short position.  
   - If ETH price ↑: Gains on ETH collateral offset losses on the short position.  

---

### **4. Why Rebalancing Matters**  
The protocol must constantly **rebalance** to stay delta-neutral:  
- **Negative PNL**: If ETH price drops, the system loses collateral value.  
  - Protocol sells ETH (or derivatives) to buy USDC, restoring collateralization.  
- **Positive PNL**: If ETH price rises, the system gains excess collateral.  
  - Protocol buys back ETH (or derivatives) to maintain the hedge.  

---

### **5. Failure in UDX’s Implementation**  
The audit finding reveals a critical flaw:  
- **USDC from rebalancing is trapped** (due to improper accounting).  
- **Result**:  
  - The system can’t access USDC needed to back UDX redemptions.  
  - Over time, UDX becomes **undercollateralized** (not enough accessible USDC to match UDX supply).  
  - Delta-neutrality breaks → UDX loses its peg.  

---

### **6. Example**  
- **Initial State**:  
  - Collateral: 1 ETH ($1,000) + Short ETH futures ($1,000).  
  - UDX Supply: $1,000 (delta-neutral).  
- **ETH Price Drops to $900**:  
  - Collateral value: $900 ETH.  
  - Protocol rebalances: Sells ETH for $900 USDC.  
  - **Expected**: UDX now backed by $900 USDC (still 1:1).  
  **Bug**:  
  - $900 USDC is locked in the vault (can’t be withdrawn).  
  - UDX remains $1,000 supply → Backed by only $900 USDC (**undercollateralized**).  

---

### **Key Takeaway**  
Delta-neutrality requires **active rebalancing** and **access to collateral**. If rebalancing locks funds (as in UDX), the system collapses. This is why proper accounting and withdrawal mechanisms are critical.

- [[2023-01-UXD#[H-05] USDC deposited to `PerpDepository.sol` are irretrievable and effectively causes UDX to become `undercollateralized`]]

## Stream

The **Stream** contract is designed to allow a payer to transfer tokens gradually to a recipient over time. Here are the key aspects: 

### What is "Stream"?(流式转账，分期付款)

- **Purpose:**  
    The contract implements a token streaming mechanism. Instead of sending a lump sum of tokens, the payer deposits tokens into the contract, which then gradually releases them to the recipient at a fixed rate (tokens per second). This approach mimics vesting or continuous payment arrangements.
    
- **Functionality:**
    
    - **Continuous Payment:** Once the stream starts, the recipient can withdraw the tokens that have vested over time.
    - **Cancellation:** Either the payer or the recipient can cancel the stream at any time. When canceled, the contract calculates and distributes the fair share of tokens to both parties.
    - **Design Origin:** The contract is a fork of the Sablier protocol, a well-known solution for streaming payments. It also leverages the `Clone` pattern to optimize gas costs by reading immutable parameters directly from the code.

### What is the "Streaming Token"?

- **Designated Token:**  
    The streaming token is the specific ERC20 token that is used for the stream. This token is central to the contract’s purpose—it's the asset being streamed from the payer to the recipient.
    
- **Handling in the Contract:**
    - **Intentional Use:** Unlike other tokens, the streaming token is intentionally deposited to fund the stream. Its balance directly affects how much the recipient can withdraw over time.
    - **Accidental Deposits Issue:** If extra amounts of the streaming token (beyond what is needed for the stream) are accidentally sent to the contract, the contract does not provide a simple rescue function to recover these excess funds. The only way to retrieve them would be to cancel the stream, which could disrupt the ongoing payment process.

### Summary

- **Stream:** A smart contract enabling time-based token payments, where funds are released gradually according to a pre-set schedule.
- **Streaming Token:** The specific ERC20 token designated for these payments. Its management is tightly integrated into the stream’s lifecycle, and any accidental surplus (beyond the required balance) is problematic because it ties directly into the stream’s accounting mechanism.

In essence, while the Stream contract facilitates smooth, continuous payments, it also requires careful handling of the designated streaming token to avoid unintended disruptions in the payment schedule.

### Example
- [[2022-12-NounsDAO#[M-07] Payer cannot withdraw accidental extra funds sent to the contract without canceling]]
	- 1. Streaming Token should be `rescue`