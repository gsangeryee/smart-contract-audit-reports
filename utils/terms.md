# Terms in DeFi

## Deposit

Deposits are like savings accounts in a bank. When lenders (or depositors) put their tokens (like USDC or ETH) into the protocol, they're essentially making deposits. These depositors expect to earn interest on their deposits, just like you earn interest on a savings account. The protocol uses these deposits as a lending pool from which borrowers can take loans. In the code we saw, deposits are tracked in a deposits tree structure and represent the protocol's primary liabilities - money it owes back to depositors.

### Key
- from (own by) lenders (depositors)
- need back to depositors
- the protocol's primary liabilities 

## Reserves

Reserves are like the bank's profit buffer or emergency fund. They come from several sources:
- A portion of the interest paid by borrowers
- Fees collected from various protocol operations
- Any excess funds generated by the protocol The key purpose of reserves is to protect depositors from losses. When something goes wrong (like a borrower defaulting), reserves are used first before touching depositor funds. In the protocol, reserves can also be auctioned off for AJNA tokens through reserve auctions, which is a unique feature compared to traditional banks.

### Reserve auctions
First, let's understand where reserves come from. When borrowers pay interest on their loans, a portion goes to depositors (like earning interest on your savings), and another portion goes into the reserves. Over time, these reserves accumulate value in the form of whatever token the pool uses (like USDC or ETH).

The auction mechanism serves several purposes:

1. Token Value Support: When people want to buy reserves, they have to use AJNA tokens. This creates natural demand for AJNA tokens. For example, if there are 1000 USDC in reserves up for auction, and people want those USDC, they need to buy and use AJNA tokens to participate in the auction.
2. Protocol Sustainability: By requiring AJNA tokens for reserve purchases, the protocol ensures that its native token has real utility and value. This is similar to how Maker requires MKR tokens for governance and fee payments.
3. Price Discovery: The auction format helps find the fair market price for reserves in terms of AJNA tokens. The auction price starts high and decreases over time, letting the market determine the right exchange rate.

### Key
- own by protocol
- less than deposit
- for protocol management
- (option) auction

## Collateral

Collateral is like the property deed you give to a bank when taking a mortgage. When borrowers want to take a loan from the protocol, they must first provide collateral - which could be NFTs in an ERC721 pool or tokens in an ERC20 pool. This collateral serves as security for the loan. If borrowers fail to repay, their collateral can be liquidated (sold) to cover the debt. In the code, collateral is tracked per borrower and can be auctioned off during liquidation events.
### Key
- from borrowers
- own by protocol, when borrowers fail to repay
- need to auction

## Deposits, reserves and collateral in one example

```plaintext
Example Flow:
1. Alice deposits 1000 USDC → becomes part of deposits
2. Bob wants to borrow 700 USDC
3. Bob deposits NFT worth 1000 USDC → becomes collateral
4. Bob borrows 700 USDC from Alice's deposit
5. Bob pays interest → some goes to Alice, some to reserves
6. If Bob defaults:
   - First, sell Bob's NFT collateral
   - If there's still unpaid debt, use reserves
   - Only if reserves are exhausted, use deposits
```


## Dust Attack

The **dust attack** exploits the precision requirements in loan repayments by manipulating the remaining loan balance through tiny ("dust") payments. Here's a step-by-step breakdown:

---

### **How the Dust Attack Works**

1. **Initial State**:
   - A borrower has a loan of **100 ETH** (`loan.amount = 100 ETH`).
   - The borrower intends to repay the full amount before expiry.

2. **Attacker Front-Runs**:
   - The attacker monitors the blockchain for the borrower's repayment transaction.
   - Before the borrower's transaction is processed, the attacker sends a **dust amount** (e.g., **1 wei**, the smallest ETH unit) to `repay()`:
     ```solidity
     repay(loanID, 1 wei); // Reduces loan.amount to 99.999999999999999999 ETH
     ```
   - This reduces `loan.amount` to **99.999... ETH** (100 ETH - 1 wei).

3. **Borrower's Transaction Fails**:
   - The borrower’s transaction attempts to repay the original **100 ETH**:
     ```solidity
     repay(loanID, 100 ETH); // Now, loan.amount is only 99.999... ETH
     ```
   - The contract calculates:
     ```solidity
     loan.amount -= 100 ETH; // Underflows (99.999... ETH - 100 ETH < 0)
     ```
   - The transaction **reverts** due to an underflow error.

4. **Loan Defaults**:
   - If this happens near the loan’s expiry time, the borrower cannot repay in time.
   - The loan defaults, and the lender seizes the collateral (e.g., NFTs, tokens worth more than the loan).

---

### **Why This Matters**
- **Unfair Defaults**: Borrowers lose collateral despite intending to repay.
- **Profit for Attackers**: Attackers may profit by acquiring collateral cheaply post-default.
- **Front-Running Vulnerability**: Miners/attackers can prioritize transactions to exploit timing.

---

### **Solution: Capping Repayments**
Modify the `repay` function to use the **minimum** of `repaid` and `loan.amount`:
```solidity
function repay(uint256 loanID, uint256 repaid) external {
    Loan storage loan = loans[loanID];
    // ...
    uint256 actualRepaid = Math.min(repaid, loan.amount); // Cap repayment
    loan.amount -= actualRepaid; // No underflow
    // ...
}
```
- **Result**: Borrowers can repay **up to** the remaining balance, preventing overpayment failures.

---

### **Key Takeaway**
By capping repayments to the remaining loan balance, the contract becomes resilient to dust attacks, ensuring borrowers can always repay without risking unintended defaults.